diff --git a/.classpath b/.classpath
index 885aadd..0e3f4fc 100644
--- a/.classpath
+++ b/.classpath
@@ -1,7 +1,7 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="lib" path="libs/asm-all-5.0.2.jar"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="lib" path="libs/asm-all-5.0.2.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
index f246d3d..a386996 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
-bin
-*~
-iagent.jar
+bin
+*~
+iagent.jar
 trace.out
\ No newline at end of file
diff --git a/.project b/.project
index 09e6ccc..b2f51cc 100644
--- a/.project
+++ b/.project
@@ -1,17 +1,17 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>sparta-testgen</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>sparta-testgen</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
index 7654d2f..b0c4b8b 100644
--- a/.settings/org.eclipse.jdt.core.prefs
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -1,291 +1,291 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
-org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_assignment=0
-org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
-org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
-org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
-org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
-org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
-org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_resources_in_try=80
-org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch=16
-org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_after_package=1
-org.eclipse.jdt.core.formatter.blank_lines_before_field=0
-org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
-org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
-org.eclipse.jdt.core.formatter.blank_lines_before_method=1
-org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
-org.eclipse.jdt.core.formatter.blank_lines_before_package=0
-org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
-org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
-org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
-org.eclipse.jdt.core.formatter.comment.format_block_comments=true
-org.eclipse.jdt.core.formatter.comment.format_header=false
-org.eclipse.jdt.core.formatter.comment.format_html=true
-org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
-org.eclipse.jdt.core.formatter.comment.format_line_comments=true
-org.eclipse.jdt.core.formatter.comment.format_source_code=true
-org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
-org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
-org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
-org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
-org.eclipse.jdt.core.formatter.comment.line_length=80
-org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
-org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=true
-org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=false
-org.eclipse.jdt.core.formatter.compact_else_if=true
-org.eclipse.jdt.core.formatter.continuation_indentation=2
-org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
-org.eclipse.jdt.core.formatter.disabling_tag=@formatter\:off
-org.eclipse.jdt.core.formatter.enabling_tag=@formatter\:on
-org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
-org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
-org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_empty_lines=false
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
-org.eclipse.jdt.core.formatter.indentation.size=4
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources=insert
-org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
-org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.join_lines_in_comments=true
-org.eclipse.jdt.core.formatter.join_wrapped_lines=true
-org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.lineSplit=80
-org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
-org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
-org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
-org.eclipse.jdt.core.formatter.tabulation.char=space
-org.eclipse.jdt.core.formatter.tabulation.size=2
-org.eclipse.jdt.core.formatter.use_on_off_tags=false
-org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=true
-org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
-org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch=true
-org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_resources_in_try=80
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
+org.eclipse.jdt.core.formatter.comment.line_length=80
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=true
+org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=false
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=2
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.disabling_tag=@formatter\:off
+org.eclipse.jdt.core.formatter.enabling_tag=@formatter\:on
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=80
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=space
+org.eclipse.jdt.core.formatter.tabulation.size=2
+org.eclipse.jdt.core.formatter.use_on_off_tags=false
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=true
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true
diff --git a/.settings/org.eclipse.jdt.ui.prefs b/.settings/org.eclipse.jdt.ui.prefs
index c2698fc..00ceab7 100644
--- a/.settings/org.eclipse.jdt.ui.prefs
+++ b/.settings/org.eclipse.jdt.ui.prefs
@@ -1,3 +1,3 @@
-eclipse.preferences.version=1
-formatter_profile=_Java Conventions [built-in] (2 spaces)
-formatter_settings_version=12
+eclipse.preferences.version=1
+formatter_profile=_Java Conventions [built-in] (2 spaces)
+formatter_settings_version=12
diff --git a/build.properties b/build.properties
index 25255c1..6521044 100644
--- a/build.properties
+++ b/build.properties
@@ -1,10 +1,10 @@
-## This is a configuration file for use by Ant when building SPARTA!
-
-build.version = 0.1
-
-### directories
-libs.dir=${basedir}/libs
-
-### file names
-asm.jar.file=${libs.dir}/asm-all-5.0.2.jar
-agent.jar.file=${basedir}/iagent.jar
+## This is a configuration file for use by Ant when building SPARTA!
+
+build.version = 0.1
+
+### directories
+libs.dir=${basedir}/libs
+
+### file names
+asm.jar.file=${libs.dir}/asm-all-5.0.2.jar
+agent.jar.file=${basedir}/iagent.jar
diff --git a/build.xml b/build.xml
index 62711c3..c1496bc 100644
--- a/build.xml
+++ b/build.xml
@@ -1,89 +1,89 @@
-<project name="sparta-code" default="build" basedir=".">
-
-    <description>
-      This is the REPLAYER project
-    </description>
-
-    <!-- loads property file -->
-    <property file="build.properties"/>
-
-    <!-- Checks for environmental consistency -->
-    <fail message="check your build.properties for missing properties!">
-        <condition>
-            <and>
-                <not> <isset property="libs.dir"/> </not>
-                <not> <isset property="asm.jar.file"/> </not>
-                <not> <isset property="agent.jar.file"/> </not>
-            </and>
-        </condition>
-    </fail>
-
-    <!-- Auxiliary names used in script --> 
-    <property name="run.tests.should.fork" value="true"/>
-    <property name="halt.on.test.failure" value="true"/>
-    <property name="src" value="src"/>
-    <property name="build" value="bin"/>
-
-    <!-- clean generated files -->
-    <target name="clean" description="Remove generated files">
-        <delete dir="${build}"/>
-        <delete file="${agent.jar.file}"/>
-        <delete file="${basedir}/trace.out"/>
-        <delete failonerror="false">
-            <fileset dir="${build.tests}" includes="**/*.class"/>
-        </delete>
-    </target>
-
-
-    <!-- Define the CLASSPATH -->
-    <path id="compile.classpath">
-      <fileset dir="${libs.dir}">
-        <include name="*.jar"/>
-      </fileset>
-      <pathelement location="${build}"/>
-    </path>
-
-    <target name ="prep">
-      <mkdir dir="${build}"/>
-    </target>
-    
-    <!-- Builds the project -->
-    <target name ="build" depends="prep">
-      <javac srcdir="${src}"
-             destdir="${build}">
-        <classpath refid="compile.classpath"/>
-      </javac>
-    </target>
-    
-    <!-- This creates ${agent.jar.file} -->
-    <target name="jar" depends="build"
-            description="Create jar file">
-      <jar destfile="${agent.jar.file}">
-        <fileset dir="${build}" includes="instrumentation/**"/>
-        <manifest>
-          <attribute name="Manifest-Version" value="1.0"/>
-          <attribute name="Premain-Class" value="instrumentation.agent.InstrumentationAgent"/>
-        </manifest>
-      </jar>
-    </target>
-
-    <target name="run-example" depends="">
-      <java classname="instrumentation.Wrapper" fork="true"
-          failonerror="true" output="trace.out" logError="true">
-        <classpath>
-          <pathelement path="${build}"/>
-          <pathelement location="${asm.jar.file}"/>
-        </classpath>
-        <arg value="examples.Arith" />
-        <jvmarg line="-javaagent:iagent.jar" />
-      </java>
-
-<!--       <java classname="replayer.Main"  -->
-<!--             failonerror="true" logError="true"> -->
-<!--         <classpath> -->
-<!--           <pathelement path="${build}"/> -->
-<!--         </classpath> -->
-<!--       </java> -->
-    </target>
-
-</project>
+<project name="sparta-code" default="build" basedir=".">
+
+    <description>
+      This is the REPLAYER project
+    </description>
+
+    <!-- loads property file -->
+    <property file="build.properties"/>
+
+    <!-- Checks for environmental consistency -->
+    <fail message="check your build.properties for missing properties!">
+        <condition>
+            <and>
+                <not> <isset property="libs.dir"/> </not>
+                <not> <isset property="asm.jar.file"/> </not>
+                <not> <isset property="agent.jar.file"/> </not>
+            </and>
+        </condition>
+    </fail>
+
+    <!-- Auxiliary names used in script --> 
+    <property name="run.tests.should.fork" value="true"/>
+    <property name="halt.on.test.failure" value="true"/>
+    <property name="src" value="src"/>
+    <property name="build" value="bin"/>
+
+    <!-- clean generated files -->
+    <target name="clean" description="Remove generated files">
+        <delete dir="${build}"/>
+        <delete file="${agent.jar.file}"/>
+        <delete file="${basedir}/trace.out"/>
+        <delete failonerror="false">
+            <fileset dir="${build.tests}" includes="**/*.class"/>
+        </delete>
+    </target>
+
+
+    <!-- Define the CLASSPATH -->
+    <path id="compile.classpath">
+      <fileset dir="${libs.dir}">
+        <include name="*.jar"/>
+      </fileset>
+      <pathelement location="${build}"/>
+    </path>
+
+    <target name ="prep">
+      <mkdir dir="${build}"/>
+    </target>
+    
+    <!-- Builds the project -->
+    <target name ="build" depends="prep">
+      <javac srcdir="${src}"
+             destdir="${build}">
+        <classpath refid="compile.classpath"/>
+      </javac>
+    </target>
+    
+    <!-- This creates ${agent.jar.file} -->
+    <target name="jar" depends="build"
+            description="Create jar file">
+      <jar destfile="${agent.jar.file}">
+        <fileset dir="${build}" includes="instrumentation/**"/>
+        <manifest>
+          <attribute name="Manifest-Version" value="1.0"/>
+          <attribute name="Premain-Class" value="instrumentation.agent.InstrumentationAgent"/>
+        </manifest>
+      </jar>
+    </target>
+
+    <target name="run-example" depends="">
+      <java classname="instrumentation.Wrapper" fork="true"
+          failonerror="true" output="trace.out" logError="true">
+        <classpath>
+          <pathelement path="${build}"/>
+          <pathelement location="${asm.jar.file}"/>
+        </classpath>
+        <arg value="examples.Arith" />
+        <jvmarg line="-javaagent:iagent.jar" />
+      </java>
+
+<!--       <java classname="replayer.Main"  -->
+<!--             failonerror="true" logError="true"> -->
+<!--         <classpath> -->
+<!--           <pathelement path="${build}"/> -->
+<!--         </classpath> -->
+<!--       </java> -->
+    </target>
+
+</project>
diff --git a/docs/assignment.txt b/docs/assignment.txt
index ad65bad..15e35bf 100644
--- a/docs/assignment.txt
+++ b/docs/assignment.txt
@@ -1,158 +1,158 @@
-http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html
-
----
-Grupo 1:
-
-ACONST_NULL
-ARETURN
-ARRAYLENGTH
-BALOAD
-ifnull
-iinc
-invokedynamic
-
----
-Grupo 2:
-
-BASTORE
-CALOAD
-CASTORE
-D2F
-invokeinterface
-jsr
-jsr_w
-l2d
-
----
-Grupo 3:
-
-D2I
-D2L
-DALOAD
-DASTORE
-l2f
-l2i
-ladd
-laload
-
----
-Grupo 4:
-
-DCMPG
-DCMPL
-DCONST
-DNEG
-land
-lastore
-lconst_0
-lconst_1
-
----
-Grupo 5:
-
-DREM
-DRETURN
-DUP_X1
-DUP_X2
-ldc_w
-ldc2_w
-ldiv
-lload
-
----
-Grupo 6:
-
-DUP2
-DUP2_X1
-DUP2_X2
-F2D
-lload_0
-lload_1
-lload_2
-lload_3
-
----
-Grupo 7:
-
-F2I
-F2L
-FADD
-FALOAD
-lmul
-lneg
-lor
-lrem
-
----
-Grupo 8:
-
-FASTORE
-FCMPG
-FCMPL
-FCONST
-lreturn
-lshl
-lshr
-FDIV
-
----
-Grupo 9:
-
-lstore
-FLOAD
-FMUL
-FNEG
-lstore_0
-lstore_1
-lstore_2
-lstore_3
-
----
-Grupo 10:
-
-FREM
-FRETURN
-FSTORE
-FSUB
-lsub
-lushr
-nop
-pop2
-
----
-Grupo 11:
-
-goto_w
-i2b
-i2c
-i2d
-ret
-saload
-sastore
-swap
-
----
-Grupo 12:
-
-i2f
-i2l
-i2s
-if_acmpeq
-ifgt
-ifle
-
----
-Grupo 13:
-
-if_acmpne
-if_icmpeq
-ifeq
-ifge
-iflt
-ifne
-ifnonnull
-
----
-Grupo 14:
-
-tableswitch
+http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html
+
+---
+Grupo 1:
+
+ACONST_NULL
+ARETURN
+ARRAYLENGTH
+BALOAD
+ifnull
+iinc
+invokedynamic
+
+---
+Grupo 2:
+
+BASTORE
+CALOAD
+CASTORE
+D2F
+invokeinterface
+jsr
+jsr_w
+l2d
+
+---
+Grupo 3:
+
+D2I
+D2L
+DALOAD
+DASTORE
+l2f
+l2i
+ladd
+laload
+
+---
+Grupo 4:
+
+DCMPG
+DCMPL
+DCONST
+DNEG
+land
+lastore
+lconst_0
+lconst_1
+
+---
+Grupo 5:
+
+DREM
+DRETURN
+DUP_X1
+DUP_X2
+ldc_w
+ldc2_w
+ldiv
+lload
+
+---
+Grupo 6:
+
+DUP2
+DUP2_X1
+DUP2_X2
+F2D
+lload_0
+lload_1
+lload_2
+lload_3
+
+---
+Grupo 7:
+
+F2I
+F2L
+FADD
+FALOAD
+lmul
+lneg
+lor
+lrem
+
+---
+Grupo 8:
+
+FASTORE
+FCMPG
+FCMPL
+FCONST
+lreturn
+lshl
+lshr
+FDIV
+
+---
+Grupo 9:
+
+lstore
+FLOAD
+FMUL
+FNEG
+lstore_0
+lstore_1
+lstore_2
+lstore_3
+
+---
+Grupo 10:
+
+FREM
+FRETURN
+FSTORE
+FSUB
+lsub
+lushr
+nop
+pop2
+
+---
+Grupo 11:
+
+goto_w
+i2b
+i2c
+i2d
+ret
+saload
+sastore
+swap
+
+---
+Grupo 12:
+
+i2f
+i2l
+i2s
+if_acmpeq
+ifgt
+ifle
+
+---
+Grupo 13:
+
+if_acmpne
+if_icmpeq
+ifeq
+ifge
+iflt
+ifne
+ifnonnull
+
+---
+Grupo 14:
+
+tableswitch
diff --git a/docs/groups.txt b/docs/groups.txt
index 2c6b7b3..dbd49f1 100644
--- a/docs/groups.txt
+++ b/docs/groups.txt
@@ -1,61 +1,61 @@
-Grupo 1:
-Larissa Navarro Passos de Araujo (lnpa)
-Leonardo José de Andrade Costa Santos (ljacs)
-Maria Gabriela Toledo de Moraes Cardoso (mgtmc)
-
-Grupo 2:
-Bertha Maria Correia Andaluz (bmca)
-Duhan Caraciolo Maia Souza (dcms2)
-Lucas Almeida Pereira de Lima (lapl)
-
-Grupo 3:
-Guilherme Palma Peixoto (gpp)
-Rafael Acevedo de Aguiar (raa7)
-
-Grupo 4:
-Eduardo de Albuquerque Pires (eap3)
-Mateus Moury Fernandes da Rosa Borges (mmfrb)
-Vinícius de Moraes Rêgo Cousseau (vmrc)
-
-Grupo 5:
-Arthur Lubambo Peixoto Accioly (alpa)
-Franklin Leandro Acioly Lucena (flal)
-Rodrigo de Melo Silva (rms10)
-
-Grupo 6:
-Antonio Alves Correia (aac)
-Bruno Resende Pinheiro (brp)
-
-Grupo 7:
-Fernando Maranhão Pessoa Nazareth
-Everton Martins Guimarães
-
-Grupo 8:
-Miguel Rodrigues Araújo (mra2)
-Raissa Gabrielle da Cunha Andrade (rgca)
-
-Grupo 9:
-George Oliveira (ghao)
-Lucas Nunes (lns2)
-Natanael Santos (nss)
-
-Grupo 10:
-Nícolas Oliveira (nogn)
-Rafael Monteiro (rmfm)
-
-Grupo 11:
-Lucas da Fonseca Netto (lfn2)
-João Pedro de Carvalho Magalhães (jpcm)
-
-Grupo 12:
-Germano Zaicaner (gz)
-Hugo Bessa (hrba)
-Vitor Maristane (vhma)
-
-Grupo 13:
-Pedro Henriques de Faria Neves (phfn)
-Victor Chaves Casé (vcc3)
-
-Grupo 14:
-Carlos Rafael de Oliveira do Amaral Leitão (croal)
-Juliane Sabrina Magalhães de Nascimento (jsmn)
+Grupo 1:
+Larissa Navarro Passos de Araujo (lnpa)
+Leonardo José de Andrade Costa Santos (ljacs)
+Maria Gabriela Toledo de Moraes Cardoso (mgtmc)
+
+Grupo 2:
+Bertha Maria Correia Andaluz (bmca)
+Duhan Caraciolo Maia Souza (dcms2)
+Lucas Almeida Pereira de Lima (lapl)
+
+Grupo 3:
+Guilherme Palma Peixoto (gpp)
+Rafael Acevedo de Aguiar (raa7)
+
+Grupo 4:
+Eduardo de Albuquerque Pires (eap3)
+Mateus Moury Fernandes da Rosa Borges (mmfrb)
+Vinícius de Moraes Rêgo Cousseau (vmrc)
+
+Grupo 5:
+Arthur Lubambo Peixoto Accioly (alpa)
+Franklin Leandro Acioly Lucena (flal)
+Rodrigo de Melo Silva (rms10)
+
+Grupo 6:
+Antonio Alves Correia (aac)
+Bruno Resende Pinheiro (brp)
+
+Grupo 7:
+Fernando Maranhão Pessoa Nazareth
+Everton Martins Guimarães
+
+Grupo 8:
+Miguel Rodrigues Araújo (mra2)
+Raissa Gabrielle da Cunha Andrade (rgca)
+
+Grupo 9:
+George Oliveira (ghao)
+Lucas Nunes (lns2)
+Natanael Santos (nss)
+
+Grupo 10:
+Nícolas Oliveira (nogn)
+Rafael Monteiro (rmfm)
+
+Grupo 11:
+Lucas da Fonseca Netto (lfn2)
+João Pedro de Carvalho Magalhães (jpcm)
+
+Grupo 12:
+Germano Zaicaner (gz)
+Hugo Bessa (hrba)
+Vitor Maristane (vhma)
+
+Grupo 13:
+Pedro Henriques de Faria Neves (phfn)
+Victor Chaves Casé (vcc3)
+
+Grupo 14:
+Carlos Rafael de Oliveira do Amaral Leitão (croal)
+Juliane Sabrina Magalhães de Nascimento (jsmn)
diff --git a/docs/missing-instructions.txt b/docs/missing-instructions.txt
index d1f373e..de95069 100644
--- a/docs/missing-instructions.txt
+++ b/docs/missing-instructions.txt
@@ -1,11 +1,11 @@
---
-ATHROW
-BREAKPOINT
-CHECKCAST
-impdep1
-impdep2
-instanceof
-monitorenter
-monitorexit
-multianewarray
-wide
+--
+ATHROW
+BREAKPOINT
+CHECKCAST
+impdep1
+impdep2
+instanceof
+monitorenter
+monitorexit
+multianewarray
+wide
diff --git a/manifest.mf b/manifest.mf
index eee8fce..f2442a9 100644
--- a/manifest.mf
+++ b/manifest.mf
@@ -1,3 +1,3 @@
-Manifest-Version: 1.0
-Premain-Class: instrumentation.agent.InstrumentationAgent
-Created-By: 1.6.0_06 (Sun Microsystems Inc.)
+Manifest-Version: 1.0
+Premain-Class: instrumentation.agent.InstrumentationAgent
+Created-By: 1.6.0_06 (Sun Microsystems Inc.)
diff --git a/runall.sh b/runall.sh
index dcd09af..d00d52c 100755
--- a/runall.sh
+++ b/runall.sh
@@ -11,9 +11,6 @@ PGMS=(
 "examples.Enum"
 "examples.Switch"
 "examples.StaticRef"
-"examples.LongTests"
-"examples.FloatTest"
-"examples.Test_mra2"
 # "instrumentation.examples.LibraryClasses"
 )
 
diff --git a/src/examples/Arith.java b/src/examples/Arith.java
index 07c2fda..4cc2879 100644
--- a/src/examples/Arith.java
+++ b/src/examples/Arith.java
@@ -1,14 +1,14 @@
-package examples;
-
-public class Arith {
-  
-  public static void main(String[] args) {
-    int x = 10;
-    x = x * 100 + 23 - 29 / 4 ^ 4 % 2 & 43 | 1000;
-    
-    
-    double y = 10;
-    y = y * 100 + 23 - 29 / 4 % 243;
-  }
-
-}
+package examples;
+
+public class Arith {
+  
+  public static void main(String[] args) {
+    int x = 10;
+    x = x * 100 + 23 - 29 / 4 ^ 4 % 2 & 43 | 1000;
+    
+    
+    double y = 10;
+    y = y * 100 + 23 - 29 / 4 % 243;
+  }
+
+}
diff --git a/src/examples/ControlFlow.java b/src/examples/ControlFlow.java
index a879f95..3d04490 100644
--- a/src/examples/ControlFlow.java
+++ b/src/examples/ControlFlow.java
@@ -1,41 +1,41 @@
-package examples;
-
-public class ControlFlow {
-
-  static void foo(int a, int b, int c) {
-    int bigger, mid, smaller;
-    mid = 0;
-    
-    if (a <= b){
-      bigger = b;
-      smaller = a;
-    } else {
-      bigger = a;
-      smaller = b;
-    } 
-    
-    if (c >= bigger){
-      mid = bigger;
-      bigger = c;
-    } else if (c < smaller){
-      mid = smaller;
-      smaller = c;
-    }
-    
-    if (bigger == smaller){
-      bigger = bigger + 1;
-    } else {
-      smaller = mid - 1;
-    }
-    
-    if (mid > smaller){
-      mid = mid + 1;
-    }
-     
-  }
-  
-  public static void main(String[] args) {
-    foo(5, 10, 7);
-  }
-  
+package examples;
+
+public class ControlFlow {
+
+  static void foo(int a, int b, int c) {
+    int bigger, mid, smaller;
+    mid = 0;
+    
+    if (a <= b){
+      bigger = b;
+      smaller = a;
+    } else {
+      bigger = a;
+      smaller = b;
+    } 
+    
+    if (c >= bigger){
+      mid = bigger;
+      bigger = c;
+    } else if (c < smaller){
+      mid = smaller;
+      smaller = c;
+    }
+    
+    if (bigger == smaller){
+      bigger = bigger + 1;
+    } else {
+      smaller = mid - 1;
+    }
+    
+    if (mid > smaller){
+      mid = mid + 1;
+    }
+     
+  }
+  
+  public static void main(String[] args) {
+    foo(5, 10, 7);
+  }
+  
 }
\ No newline at end of file
diff --git a/src/examples/Enum.java b/src/examples/Enum.java
index 626a277..e350875 100644
--- a/src/examples/Enum.java
+++ b/src/examples/Enum.java
@@ -1,12 +1,12 @@
-package examples;
-
-public class Enum {
-  
-  enum MODEL {FORD, FIAT};
-  
-  public static void main(String[] args) {
-    MODEL md = MODEL.FORD;
-    int k = md.ordinal();
-  }
-  
-}
+package examples;
+
+public class Enum {
+  
+  enum MODEL {FORD, FIAT};
+  
+  public static void main(String[] args) {
+    MODEL md = MODEL.FORD;
+    int k = md.ordinal();
+  }
+  
+}
diff --git a/src/examples/IntArrays.java b/src/examples/IntArrays.java
index fdf59e1..2f4bc1d 100644
--- a/src/examples/IntArrays.java
+++ b/src/examples/IntArrays.java
@@ -1,12 +1,12 @@
-package examples;
-
-public class IntArrays {
-  
-  public static void main(String[] args) {
-    int[] ar = new int[]{10, 5};
-    int t = ar[0];
-    ar[0] = ar[1];
-    ar[1] = t;
-  }
-
-}
+package examples;
+
+public class IntArrays {
+  
+  public static void main(String[] args) {
+    int[] ar = new int[]{10, 5};
+    int t = ar[0];
+    ar[0] = ar[1];
+    ar[1] = t;
+  }
+
+}
diff --git a/src/examples/LibraryClasses.java b/src/examples/LibraryClasses.java
index 0664078..2b8b4a9 100644
--- a/src/examples/LibraryClasses.java
+++ b/src/examples/LibraryClasses.java
@@ -1,21 +1,21 @@
-package examples;
-
-
-public class LibraryClasses {
-  
-  public static void main(String[] args) {
-    integers();
-//    strings();
-  }
-  
-  public static void integers() {
-    Integer u = new Integer(2);
-  }
-  
-  public static void strings() {
-    String s = "Hello";
-    s = s + "World";
-  }
-
-
-}
+package examples;
+
+
+public class LibraryClasses {
+  
+  public static void main(String[] args) {
+    integers();
+//    strings();
+  }
+  
+  public static void integers() {
+    Integer u = new Integer(2);
+  }
+  
+  public static void strings() {
+    String s = "Hello";
+    s = s + "World";
+  }
+
+
+}
diff --git a/src/examples/ObjectAllocation.java b/src/examples/ObjectAllocation.java
index 7db5f3d..f58fd53 100644
--- a/src/examples/ObjectAllocation.java
+++ b/src/examples/ObjectAllocation.java
@@ -1,15 +1,15 @@
-package examples;
-
-public class ObjectAllocation {
-  
-  static class NonSense {
-    int f;
-    NonSense() { }
-  }
-  
-  public static void main(String[] args) {
-    NonSense ns = new NonSense();
-    ns.f = 5;
-  }
-
-}
+package examples;
+
+public class ObjectAllocation {
+  
+  static class NonSense {
+    int f;
+    NonSense() { }
+  }
+  
+  public static void main(String[] args) {
+    NonSense ns = new NonSense();
+    ns.f = 5;
+  }
+
+}
diff --git a/src/examples/RefArrayAllocation.java b/src/examples/RefArrayAllocation.java
index e05d2a6..605f71c 100644
--- a/src/examples/RefArrayAllocation.java
+++ b/src/examples/RefArrayAllocation.java
@@ -1,16 +1,16 @@
-package examples;
-
-public class RefArrayAllocation {
-
-  static class NonSense {
-    String[] ar = new String[]{};
-  }
-  
-  public static void main(String[] args) {
-    
-    @SuppressWarnings("unused")
-    NonSense ns = new NonSense();
-    
-  }
-
-}
+package examples;
+
+public class RefArrayAllocation {
+
+  static class NonSense {
+    String[] ar = new String[]{};
+  }
+  
+  public static void main(String[] args) {
+    
+    @SuppressWarnings("unused")
+    NonSense ns = new NonSense();
+    
+  }
+
+}
diff --git a/src/examples/RefArrays.java b/src/examples/RefArrays.java
index e53908c..41b7929 100644
--- a/src/examples/RefArrays.java
+++ b/src/examples/RefArrays.java
@@ -1,24 +1,24 @@
-package examples;
-
-
-public class RefArrays {
-
-  static int K;
-
-  static class WTF {
-    String[] ar = new String[]{"A", "B"};
-    WTF() {
-      K = 10;
-    }
-  }
-
-  @SuppressWarnings("unused")
-  public static void main(String[] args) {
-    WTF wtf = new WTF();
-    wtf.ar[1] = ""; // killed
-    String s = wtf.ar[1];
-    K++; // used
-    s = wtf.ar[0];
-  }
-
-}
+package examples;
+
+
+public class RefArrays {
+
+  static int K;
+
+  static class WTF {
+    String[] ar = new String[]{"A", "B"};
+    WTF() {
+      K = 10;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  public static void main(String[] args) {
+    WTF wtf = new WTF();
+    wtf.ar[1] = ""; // killed
+    String s = wtf.ar[1];
+    K++; // used
+    s = wtf.ar[0];
+  }
+
+}
diff --git a/src/examples/StaticRef.java b/src/examples/StaticRef.java
index f48cfc8..7a704c2 100644
--- a/src/examples/StaticRef.java
+++ b/src/examples/StaticRef.java
@@ -1,12 +1,12 @@
-package examples;
-
-public class StaticRef {
-  
-  static String s;
-  static Object t;
-  
-  public static void main(String[] args) {
-    s = "Hello";
-    t = s;
-  }
-}
+package examples;
+
+public class StaticRef {
+  
+  static String s;
+  static Object t;
+  
+  public static void main(String[] args) {
+    s = "Hello";
+    t = s;
+  }
+}
diff --git a/src/examples/Switch.java b/src/examples/Switch.java
index 8a69fd0..e432aaa 100644
--- a/src/examples/Switch.java
+++ b/src/examples/Switch.java
@@ -1,37 +1,37 @@
-package examples;
-
-public class Switch {
-  
-  enum MODEL {FORD, FIAT, VOKSWAGEN};
-  
-  public static void main(String[] args) {
-    MODEL md = MODEL.FIAT;
-  }
-  
-//  public static void main(String[] args) {
-//    int k = 10;
-//    switch (k) {
-//    case 1:
-//      k = 55;
-//      break;
-//    case 10:
-//      k = -1;
-//      break;
-//    default:
-//      break;
-//    }
-//    
-//    
-//    MODEL md = MODEL.FIAT;
-//    switch (md) {
-//    case FORD:
-//      k = 99;
-//      break;
-//
-//    default:
-//      break;
-//    }
-//    
-//  }
-
-}
+package examples;
+
+public class Switch {
+  
+  enum MODEL {FORD, FIAT, VOKSWAGEN};
+  
+  public static void main(String[] args) {
+    MODEL md = MODEL.FIAT;
+  }
+  
+//  public static void main(String[] args) {
+//    int k = 10;
+//    switch (k) {
+//    case 1:
+//      k = 55;
+//      break;
+//    case 10:
+//      k = -1;
+//      break;
+//    default:
+//      break;
+//    }
+//    
+//    
+//    MODEL md = MODEL.FIAT;
+//    switch (md) {
+//    case FORD:
+//      k = 99;
+//      break;
+//
+//    default:
+//      break;
+//    }
+//    
+//  }
+
+}
diff --git a/src/instrumentation/Util.java b/src/instrumentation/Util.java
index 6f35b5c..58037bb 100644
--- a/src/instrumentation/Util.java
+++ b/src/instrumentation/Util.java
@@ -1,14 +1,14 @@
-package instrumentation;
-
-public class Util {
-  
-  public static boolean DEBUG       = false;
-  
-  public static final boolean FILTER_INTEREST = true;
-  //TODO: should be regex
-  public static String  INTERESTED  = "examples";
-
-  public static enum KIND { EXECUTION_TRACER, INSTRUCTION_PRINTER, ENTRYEXIT, MEMACCESS }
-  public static KIND OPTION = KIND.EXECUTION_TRACER;
-  //tst
-}
+package instrumentation;
+
+public class Util {
+  
+  public static boolean DEBUG       = false;
+  
+  public static final boolean FILTER_INTEREST = true;
+  //TODO: should be regex
+  public static String  INTERESTED  = "examples";
+
+  public static enum KIND { EXECUTION_TRACER, INSTRUCTION_PRINTER, ENTRYEXIT, MEMACCESS }
+  public static KIND OPTION = KIND.EXECUTION_TRACER;
+  //tst
+}
diff --git a/src/instrumentation/Wrapper.java b/src/instrumentation/Wrapper.java
index de86cd2..d86bb3d 100644
--- a/src/instrumentation/Wrapper.java
+++ b/src/instrumentation/Wrapper.java
@@ -1,25 +1,25 @@
-package instrumentation;
-
-import instrumentation.options.stmt.ExecutionTracer;
-
-public class Wrapper {
-  
-  public static void main(String[] args) throws Exception {
-    
-    
-    /**
-     * run test of interest and hijack log
-     */
-    if (args == null || args.length == 0) {
-      throw new IllegalArgumentException("missing input");
-    }
-    Class.forName(args[0]).getDeclaredMethod("main", String[].class).invoke(null, (Object) null);
-    
-    
-    /**
-     * store in a file
-     */
-    ExecutionTracer.dump();
-  }
-
-}
+package instrumentation;
+
+import instrumentation.options.stmt.ExecutionTracer;
+
+public class Wrapper {
+  
+  public static void main(String[] args) throws Exception {
+    
+    
+    /**
+     * run test of interest and hijack log
+     */
+    if (args == null || args.length == 0) {
+      throw new IllegalArgumentException("missing input");
+    }
+    Class.forName(args[0]).getDeclaredMethod("main", String[].class).invoke(null, (Object) null);
+    
+    
+    /**
+     * store in a file
+     */
+    ExecutionTracer.dump();
+  }
+
+}
diff --git a/src/instrumentation/agent/ClassInstrumenter.java b/src/instrumentation/agent/ClassInstrumenter.java
index 0bf5ec2..a0c0916 100644
--- a/src/instrumentation/agent/ClassInstrumenter.java
+++ b/src/instrumentation/agent/ClassInstrumenter.java
@@ -1,102 +1,102 @@
-package instrumentation.agent;
-
-import instrumentation.Util;
-import instrumentation.options.ITransform;
-import instrumentation.options.entryexit.EntryExitTransformer;
-import instrumentation.options.memaccess.MemoryAccessTransformer;
-import instrumentation.options.stmt.ExecutionTracer;
-import instrumentation.options.stmt.InstructionPrinter;
-
-import java.io.PrintWriter;
-import java.lang.instrument.ClassFileTransformer;
-import java.lang.instrument.IllegalClassFormatException;
-import java.security.ProtectionDomain;
-
-import org.objectweb.asm.ClassReader;
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.util.TraceClassVisitor;
-
-
-public class ClassInstrumenter implements ClassFileTransformer {
-
-  /************************************************************
-   * 
-   * This method is invoked for every class that the JVM is 
-   * about to load.  It triggers the instrumentation on a class.
-   * 
-   * 1. JVM may install a class file transformer if there is an 
-   *    instrumentation agent installed (see ClassInstrumenter.java)
-   *     
-   * 2. JVM requests a class to the class loader
-   * 
-   * 3. Before loading any class file, the ClassLoader calls 
-   *    transform (see method below) in it.  This enables one to change
-   *    the class file however he wants using any instrumentation library
-   *    he wants.  We chose ASM. 
-   * 
-   *********************************************************/
-  @SuppressWarnings("unused")
-  @Override
-  public byte[] transform(ClassLoader loader, String className,
-      Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
-      byte[] classfileBuffer) throws IllegalClassFormatException {
-    byte[] result = classfileBuffer;
-
-    /**
-     * The class will be instrumented only if 
-     * it is a class of "interest"
-     */
-    if (!Util.FILTER_INTEREST || className.contains(Util.INTERESTED)) {
-        //System.out.print("instrumenting: " + className + "\n");      
-      // building class node object
-      ClassReader cr = new ClassReader(classfileBuffer);
-      ClassNode cnode = new ClassNode(Opcodes.ASM4);
-      cr.accept(cnode, 0);
-
-      // transforming class node object
-
-      ITransform transformer;
-      switch (Util.OPTION) {
-      case ENTRYEXIT:
-        transformer = new EntryExitTransformer();
-        break;
-      case MEMACCESS:
-        transformer = new MemoryAccessTransformer();
-        break;
-      case INSTRUCTION_PRINTER:
-        transformer = new InstructionPrinter();
-        break;
-      case EXECUTION_TRACER:
-        transformer = new ExecutionTracer();
-        break;
-      default:
-        throw new UnsupportedOperationException();
-      }
-
-      try {
-        transformer.transform(cnode);
-      }
-      catch (RuntimeException _) {
-        _.printStackTrace();
-        throw _;
-      }
-
-      // building JVM bytecodes
-      ClassWriter cw = new ClassWriter(0);
-
-      if (Util.DEBUG) {
-        TraceClassVisitor tracer = new TraceClassVisitor(cw, new PrintWriter(System.out));
-        cnode.accept(tracer);
-      } else {
-        cnode.accept(cw);
-      }
-
-      // spitting out modified bytecodes
-      result = cw.toByteArray();
-    }
-
-    return result;
-  }
+package instrumentation.agent;
+
+import instrumentation.Util;
+import instrumentation.options.ITransform;
+import instrumentation.options.entryexit.EntryExitTransformer;
+import instrumentation.options.memaccess.MemoryAccessTransformer;
+import instrumentation.options.stmt.ExecutionTracer;
+import instrumentation.options.stmt.InstructionPrinter;
+
+import java.io.PrintWriter;
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.security.ProtectionDomain;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.util.TraceClassVisitor;
+
+
+public class ClassInstrumenter implements ClassFileTransformer {
+
+  /************************************************************
+   * 
+   * This method is invoked for every class that the JVM is 
+   * about to load.  It triggers the instrumentation on a class.
+   * 
+   * 1. JVM may install a class file transformer if there is an 
+   *    instrumentation agent installed (see ClassInstrumenter.java)
+   *     
+   * 2. JVM requests a class to the class loader
+   * 
+   * 3. Before loading any class file, the ClassLoader calls 
+   *    transform (see method below) in it.  This enables one to change
+   *    the class file however he wants using any instrumentation library
+   *    he wants.  We chose ASM. 
+   * 
+   *********************************************************/
+  @SuppressWarnings("unused")
+  @Override
+  public byte[] transform(ClassLoader loader, String className,
+      Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+      byte[] classfileBuffer) throws IllegalClassFormatException {
+    byte[] result = classfileBuffer;
+
+    /**
+     * The class will be instrumented only if 
+     * it is a class of "interest"
+     */
+    if (!Util.FILTER_INTEREST || className.contains(Util.INTERESTED)) {
+        //System.out.print("instrumenting: " + className + "\n");      
+      // building class node object
+      ClassReader cr = new ClassReader(classfileBuffer);
+      ClassNode cnode = new ClassNode(Opcodes.ASM4);
+      cr.accept(cnode, 0);
+
+      // transforming class node object
+
+      ITransform transformer;
+      switch (Util.OPTION) {
+      case ENTRYEXIT:
+        transformer = new EntryExitTransformer();
+        break;
+      case MEMACCESS:
+        transformer = new MemoryAccessTransformer();
+        break;
+      case INSTRUCTION_PRINTER:
+        transformer = new InstructionPrinter();
+        break;
+      case EXECUTION_TRACER:
+        transformer = new ExecutionTracer();
+        break;
+      default:
+        throw new UnsupportedOperationException();
+      }
+
+      try {
+        transformer.transform(cnode);
+      }
+      catch (RuntimeException _) {
+        _.printStackTrace();
+        throw _;
+      }
+
+      // building JVM bytecodes
+      ClassWriter cw = new ClassWriter(0);
+
+      if (Util.DEBUG) {
+        TraceClassVisitor tracer = new TraceClassVisitor(cw, new PrintWriter(System.out));
+        cnode.accept(tracer);
+      } else {
+        cnode.accept(cw);
+      }
+
+      // spitting out modified bytecodes
+      result = cw.toByteArray();
+    }
+
+    return result;
+  }
 }
\ No newline at end of file
diff --git a/src/instrumentation/agent/InstrumentationAgent.java b/src/instrumentation/agent/InstrumentationAgent.java
index d69ef13..9985005 100644
--- a/src/instrumentation/agent/InstrumentationAgent.java
+++ b/src/instrumentation/agent/InstrumentationAgent.java
@@ -1,33 +1,33 @@
-package instrumentation.agent;
-
-
-import java.io.IOException;
-import java.lang.instrument.Instrumentation;
-
-
-/************************************************
- * This is the instrumentation agent class that 
- * must be passed in the command-line using
- * the command below.
- * 
- * -javaagent:jarpath[=options]
- ***********************************************/
-
-public class InstrumentationAgent {
-
-  /**
-   * Prints modified bytecodes on the screen, if enabled	
-   */
-  public static boolean DEBUG = false;
-
-  /**
-   * This method is the entry point of the java agent.
-   */
-  public static void premain (String agentArgs, Instrumentation inst) throws IOException {
-    // add the transformation that you want here
-    // this will hook your transformation to the JVM
-    // infrastructure
-    inst.addTransformer(new ClassInstrumenter());
-  }
-  
+package instrumentation.agent;
+
+
+import java.io.IOException;
+import java.lang.instrument.Instrumentation;
+
+
+/************************************************
+ * This is the instrumentation agent class that 
+ * must be passed in the command-line using
+ * the command below.
+ * 
+ * -javaagent:jarpath[=options]
+ ***********************************************/
+
+public class InstrumentationAgent {
+
+  /**
+   * Prints modified bytecodes on the screen, if enabled	
+   */
+  public static boolean DEBUG = false;
+
+  /**
+   * This method is the entry point of the java agent.
+   */
+  public static void premain (String agentArgs, Instrumentation inst) throws IOException {
+    // add the transformation that you want here
+    // this will hook your transformation to the JVM
+    // infrastructure
+    inst.addTransformer(new ClassInstrumenter());
+  }
+  
 }
\ No newline at end of file
diff --git a/src/instrumentation/options/ITransform.java b/src/instrumentation/options/ITransform.java
index 6a3d863..c014045 100644
--- a/src/instrumentation/options/ITransform.java
+++ b/src/instrumentation/options/ITransform.java
@@ -1,7 +1,7 @@
-package instrumentation.options;
-
-import org.objectweb.asm.tree.ClassNode;
-
-public interface ITransform {
-  void transform(ClassNode cn);
-}
+package instrumentation.options;
+
+import org.objectweb.asm.tree.ClassNode;
+
+public interface ITransform {
+  void transform(ClassNode cn);
+}
diff --git a/src/instrumentation/options/entryexit/EntryExitTransformer.java b/src/instrumentation/options/entryexit/EntryExitTransformer.java
index c8aab88..e6e8960 100644
--- a/src/instrumentation/options/entryexit/EntryExitTransformer.java
+++ b/src/instrumentation/options/entryexit/EntryExitTransformer.java
@@ -1,110 +1,110 @@
-package instrumentation.options.entryexit;
-
-import instrumentation.options.ITransform;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.tree.AbstractInsnNode;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.tree.InsnList;
-import org.objectweb.asm.tree.LabelNode;
-import org.objectweb.asm.tree.LdcInsnNode;
-import org.objectweb.asm.tree.LineNumberNode;
-import org.objectweb.asm.tree.MethodInsnNode;
-import org.objectweb.asm.tree.MethodNode;
-import org.objectweb.asm.tree.TryCatchBlockNode;
-
-public class EntryExitTransformer implements ITransform { 
-
-  public EntryExitTransformer() { } 
-
-  @SuppressWarnings("unchecked")
-  public void transform(ClassNode cn) {
-
-    for (MethodNode mn : (List<MethodNode>) cn.methods) {
-      //<init> - class initialization;
-      //<clinit> - static block initialization
-      //      if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name)) {
-      //        continue;
-      //      }
-      InsnList insns = mn.instructions;
-      if (insns.size() == 0) { 
-        continue;
-      }
-      Iterator<AbstractInsnNode> j = insns.iterator();
-
-      List<LabelNode> exceptionHandlers = new ArrayList<LabelNode>();
-
-      //TODO: FIX THIS      
-      //      if (mn.name.contains("xfoo")) {
-      for (int i = 0; i < mn.tryCatchBlocks.size(); i++) {
-        LabelNode lnode = ((TryCatchBlockNode) mn.tryCatchBlocks.get(i)).handler;
-        if (lnode != null) {
-          exceptionHandlers.add(lnode);
-        }
-      }
-      //      }
-
-      //      int stackIncrement = 0;
-      while (j.hasNext()) {
-        AbstractInsnNode in = j.next();
-        //if (mn.name.contains("xfoo")) {
-        //          System.out.println(in.getType() + " " + (in.getType()==AbstractInsnNode.LINE) + " " + in.toString());
-        //}
-        int op = in.getOpcode();
-
-        boolean isRet = (op >= Opcodes.IRETURN && op <= Opcodes.RETURN) || op == Opcodes.RET;
-        //        boolean isLast = !j.hasNext();
-
-        InsnList il = new InsnList();
-        if (op == Opcodes.ATHROW) {
-          // notify on explicit throws
-          notify(cn, mn, il, "throwE");
-          insns.insert(in.getPrevious(), il);
-        } else if (isRet) {
-          // notify on exits
-          notify(cn, mn, il, "exit");
-          insns.insert(in.getPrevious(), il);
-        } else if (exceptionHandlers.contains(in)) {
-          // notify on catches
-          notify(cn, mn, il, "catchE");
-          AbstractInsnNode place = getNextRelevant(j);
-          insns.insert(place.getPrevious(), il);          
-        }
-
-        // this is an over-approximation -M
-        //        stackIncrement = Math.max(stackIncrement, il.size());
-
-      }
-      // notify on entry
-      InsnList il = new InsnList(); 
-      notify(cn, mn, il, "entry");      
-      insns.insert(il); 
-      mn.maxStack += 10;
-    } 
-  }
-
-  private AbstractInsnNode getNextRelevant(Iterator<AbstractInsnNode> it) {
-    AbstractInsnNode insn = null;
-    while (it.hasNext()) {
-      insn = it.next();
-      if (insn != null && !(insn instanceof LineNumberNode)) {
-        break;
-      }
-    }
-    if (insn == null) {
-      throw new RuntimeException();
-    }
-    return insn;
-  }
-
-  private void notify(ClassNode cn, MethodNode mn, InsnList il, String event) {
-    String fullyQmName = "L" + cn.name + ";" + mn.name + mn.desc;
-    il.add(new LdcInsnNode(fullyQmName));
-    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "callret/agent/InstrumentationState", event, "(Ljava/lang/String;)V"));
-  }
-
+package instrumentation.options.entryexit;
+
+import instrumentation.options.ITransform;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.InsnList;
+import org.objectweb.asm.tree.LabelNode;
+import org.objectweb.asm.tree.LdcInsnNode;
+import org.objectweb.asm.tree.LineNumberNode;
+import org.objectweb.asm.tree.MethodInsnNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.tree.TryCatchBlockNode;
+
+public class EntryExitTransformer implements ITransform { 
+
+  public EntryExitTransformer() { } 
+
+  @SuppressWarnings("unchecked")
+  public void transform(ClassNode cn) {
+
+    for (MethodNode mn : (List<MethodNode>) cn.methods) {
+      //<init> - class initialization;
+      //<clinit> - static block initialization
+      //      if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name)) {
+      //        continue;
+      //      }
+      InsnList insns = mn.instructions;
+      if (insns.size() == 0) { 
+        continue;
+      }
+      Iterator<AbstractInsnNode> j = insns.iterator();
+
+      List<LabelNode> exceptionHandlers = new ArrayList<LabelNode>();
+
+      //TODO: FIX THIS      
+      //      if (mn.name.contains("xfoo")) {
+      for (int i = 0; i < mn.tryCatchBlocks.size(); i++) {
+        LabelNode lnode = ((TryCatchBlockNode) mn.tryCatchBlocks.get(i)).handler;
+        if (lnode != null) {
+          exceptionHandlers.add(lnode);
+        }
+      }
+      //      }
+
+      //      int stackIncrement = 0;
+      while (j.hasNext()) {
+        AbstractInsnNode in = j.next();
+        //if (mn.name.contains("xfoo")) {
+        //          System.out.println(in.getType() + " " + (in.getType()==AbstractInsnNode.LINE) + " " + in.toString());
+        //}
+        int op = in.getOpcode();
+
+        boolean isRet = (op >= Opcodes.IRETURN && op <= Opcodes.RETURN) || op == Opcodes.RET;
+        //        boolean isLast = !j.hasNext();
+
+        InsnList il = new InsnList();
+        if (op == Opcodes.ATHROW) {
+          // notify on explicit throws
+          notify(cn, mn, il, "throwE");
+          insns.insert(in.getPrevious(), il);
+        } else if (isRet) {
+          // notify on exits
+          notify(cn, mn, il, "exit");
+          insns.insert(in.getPrevious(), il);
+        } else if (exceptionHandlers.contains(in)) {
+          // notify on catches
+          notify(cn, mn, il, "catchE");
+          AbstractInsnNode place = getNextRelevant(j);
+          insns.insert(place.getPrevious(), il);          
+        }
+
+        // this is an over-approximation -M
+        //        stackIncrement = Math.max(stackIncrement, il.size());
+
+      }
+      // notify on entry
+      InsnList il = new InsnList(); 
+      notify(cn, mn, il, "entry");      
+      insns.insert(il); 
+      mn.maxStack += 10;
+    } 
+  }
+
+  private AbstractInsnNode getNextRelevant(Iterator<AbstractInsnNode> it) {
+    AbstractInsnNode insn = null;
+    while (it.hasNext()) {
+      insn = it.next();
+      if (insn != null && !(insn instanceof LineNumberNode)) {
+        break;
+      }
+    }
+    if (insn == null) {
+      throw new RuntimeException();
+    }
+    return insn;
+  }
+
+  private void notify(ClassNode cn, MethodNode mn, InsnList il, String event) {
+    String fullyQmName = "L" + cn.name + ";" + mn.name + mn.desc;
+    il.add(new LdcInsnNode(fullyQmName));
+    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "callret/agent/InstrumentationState", event, "(Ljava/lang/String;)V"));
+  }
+
 }
\ No newline at end of file
diff --git a/src/instrumentation/options/memaccess/MemoryAccessTransformer.java b/src/instrumentation/options/memaccess/MemoryAccessTransformer.java
index 959f67c..a8f5ddc 100644
--- a/src/instrumentation/options/memaccess/MemoryAccessTransformer.java
+++ b/src/instrumentation/options/memaccess/MemoryAccessTransformer.java
@@ -1,497 +1,497 @@
-package instrumentation.options.memaccess;
-
-import instrumentation.options.ITransform;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.tree.AbstractInsnNode;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.tree.FieldInsnNode;
-import org.objectweb.asm.tree.InsnList;
-import org.objectweb.asm.tree.InsnNode;
-import org.objectweb.asm.tree.LdcInsnNode;
-import org.objectweb.asm.tree.MethodInsnNode;
-import org.objectweb.asm.tree.MethodNode;
-
-public class MemoryAccessTransformer implements ITransform { 
-
-  /** method of interest **/
-  public static String MOI = "callret/instrumentation/examples/Sample$WTF.<init>()V";
-
-
-  @SuppressWarnings("unchecked")
-  public void transform(ClassNode cn) {
-
-    for (MethodNode mn : (List<MethodNode>) cn.methods) {
-
-      // method location
-      String location = cn.name + "." + mn.name + mn.desc;
-      boolean inMOI = false;
-      if (MOI.equals(location)) {
-        inMOI = true;
-      }
-
-      InsnList insns = mn.instructions;
-      if (insns.size() == 0) { 
-        continue;
-      }
-      Iterator<AbstractInsnNode> j = insns.iterator();
-      while (j.hasNext()) {
-        AbstractInsnNode in = j.next();
-        int op = in.getOpcode();
-
-
-        if ((op >= Opcodes.IASTORE && op <= Opcodes.SASTORE) ||
-            (op >= Opcodes.IALOAD && op <= Opcodes.SALOAD)) {
-          // array writes in MOI  
-          InsnList list = arrayAccessInstr(op, location);
-          insns.insertBefore(in, list);
-          insns.remove(in);
-        } else if (in instanceof FieldInsnNode) {
-          // field name
-          FieldInsnNode tmp = (FieldInsnNode)in;
-          // class name
-          String owner = tmp.owner;
-          // field name
-          String fieldName = tmp.name;
-
-          boolean isStatic;
-          boolean isStore;
-          //TODO: this will not cover updates on field array
-          if (op == Opcodes.PUTFIELD) {
-            isStatic = false;
-            isStore = true;
-          } else if (op == Opcodes.PUTSTATIC) {
-            isStatic = true;
-            isStore = true;
-          } else if (op >= Opcodes.GETFIELD) {
-            isStatic = false;
-            isStore = false;
-          } else if (op <= Opcodes.GETSTATIC) {
-            isStatic = true;
-            isStore = false;
-          } else {
-            throw new RuntimeException("UNEXPECTED");
-          }
-
-          if (inMOI) {
-            if (isStore) {
-              InsnList list = fieldAccessInstr(isStatic, isStore, owner, fieldName, location);
-              insns.insert(in.getPrevious(), list);
-            }
-          } else if (!isStore) {
-            InsnList list = fieldAccessInstr(isStatic, isStore, owner, fieldName, location);
-            insns.insert(in.getPrevious(), list);
-          }
-        }
-      }
-      // notify on entry
-      mn.maxStack += 10;
-    } 
-  }
-
-  static class FieldAccess {
-    boolean isStatic;
-    boolean isRead;
-    Object ref;
-    String className;
-    String fieldName;
-    String source;
-    public FieldAccess(
-        boolean isStatic, 
-        boolean isRead, 
-        Object ref, 
-        String className,
-        String fieldName, 
-        String source) {
-      this.isStatic = isStatic;
-      this.isRead = isRead;
-      this.ref = ref;
-      this.className = className;
-      this.fieldName = fieldName;
-      this.source = source;
-    }
-    @Override
-    public int hashCode() {
-      return (isStatic?1:0) + (isRead?1:0) + ref.hashCode() + 
-          className.hashCode() + fieldName.hashCode() + 
-          source.hashCode(); 
-    }
-    @Override
-    public boolean equals(Object obj) {
-      boolean result = false;
-      if (obj instanceof FieldAccess) {
-        FieldAccess tmp = (FieldAccess) obj;
-        result = isStatic == tmp.isStatic && 
-            isRead == tmp.isRead && 
-            ref == tmp.ref && 
-            className.equals(tmp.className) && 
-            fieldName.equals(tmp.fieldName) &&
-            source.equals(tmp.source);
-      }
-      return result;
-    }
-  }
-
-  static class ArrayAccess {
-    Object aref;
-    int index;
-    String location;
-    public ArrayAccess(
-        Object aref,
-        int index,
-        String location) {
-      this.aref = aref;
-      this.index = index;
-      this.location = location;
-    }
-    @Override
-    public int hashCode() {
-      return aref.hashCode() + index + location.hashCode(); 
-    }
-    @Override
-    public boolean equals(Object obj) {
-      boolean result = false;
-      if (obj instanceof ArrayAccess) {
-        ArrayAccess tmp = (ArrayAccess) obj;
-        result = 
-            aref == tmp.aref &&
-            index == tmp.index &&
-            location.equals(tmp.location);
-      }
-      return result;
-    }
-  }
-
-  /**
-   * writes on regular fields
-   */
-  static Map<Object, List<FieldAccess>> instanceWrites = new HashMap<Object, List<FieldAccess>>();
-  static Map<String, List<FieldAccess>> staticWrites = new HashMap<String, List<FieldAccess>>(); 
-
-  /**
-   * reads on regular fields
-   */
-  static Map<Object, List<FieldAccess>> instanceReads = new HashMap<Object, List<FieldAccess>>();
-  static Map<String, List<FieldAccess>> staticReads = new HashMap<String, List<FieldAccess>>();    
-
-  /**
-   * writes and reads on array fields
-   */
-  static Map<Object, Set<Integer>> arrayWrites = new HashMap<Object, Set<Integer>>();
-  static Set<ArrayAccess> arrayReads = new HashSet<ArrayAccess>();
-
-
-  public static void dump() {
-    System.out.printf("%d static field interactions!\n", staticReads.size());
-    System.out.printf("%d instance field interactions!\n", instanceReads.size());
-    System.out.printf("%d array interactions!\n", arrayReads.size());
-  }
-
-  /*************** generation of instrumentation code ****************/
-
-  private InsnList fieldAccessInstr(boolean isStatic, boolean isStore, String className, String fieldName, String source) {
-    InsnList il = new InsnList();    
-    String adviceClassName = "callret/instrumentation/MemoryAccessTransformer";
-    String adviceMethodName;
-    if (isStore) {
-      adviceMethodName = "put";
-    } else {
-      adviceMethodName = "get";
-    }
-    if (isStatic) {
-      adviceMethodName += "static";
-    } else {      
-      adviceMethodName += "field";
-    }
-    // filling instruction list with other arguments
-    String signature;
-    if (isStatic) {
-      signature = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V";
-    } else { /*instance*/
-      signature = "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V";
-      if (isStore) {
-        il.add(new InsnNode(Opcodes.DUP2));
-        il.add(new InsnNode(Opcodes.POP));
-      } else {
-        il.add(new InsnNode(Opcodes.DUP));
-      }
-    }
-    il.add(new LdcInsnNode(className));
-    il.add(new LdcInsnNode(fieldName));
-    il.add(new LdcInsnNode(source));    
-    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, adviceClassName, adviceMethodName, signature));
-    return il;
-  }
-
-
-  private InsnList arrayAccessInstr(int op, String location) {
-    InsnList il = new InsnList();    
-    String adviceClassName = "callret/instrumentation/MemoryAccessTransformer";
-    // filling instruction list with other arguments
-    String adviceMethodName;
-    String signature;
-    switch (op) {
-    /* stores */
-    case Opcodes.IASTORE:
-      adviceMethodName = "iastore";
-      signature = "([IIILjava/lang/String;)V";      
-      break;
-    case Opcodes.LASTORE:
-      adviceMethodName = "lastore";
-      signature = "([LILLjava/lang/String;)V";      
-      break;
-    case Opcodes.FASTORE:
-      adviceMethodName = "fastore";
-      signature = "([FIFLjava/lang/String;)V";      
-      break;
-    case Opcodes.DASTORE:
-      adviceMethodName = "dastore";
-      signature = "([DIDLjava/lang/String;)V";      
-      break;
-    case Opcodes.AASTORE:
-      adviceMethodName = "aastore";
-      signature = "([Ljava/lang/Object;ILjava/lang/Object;Ljava/lang/String;)V";      
-      break;
-    case Opcodes.BASTORE:
-      adviceMethodName = "bastore";
-      signature = "([BIBLjava/lang/String;)V";      
-      break;
-    case Opcodes.CASTORE:
-      adviceMethodName = "castore";
-      signature = "([CICLjava/lang/String;)V";      
-      break;
-    case Opcodes.SASTORE:
-      adviceMethodName = "sastore";
-      signature = "([SISLjava/lang/String;)V";      
-      break;
-      /* loads */
-    case Opcodes.IALOAD:
-      adviceMethodName = "iaload";
-      signature = "([IILjava/lang/String;)I";      
-      break;
-    case Opcodes.LALOAD:
-      adviceMethodName = "laload";
-      signature = "([LILjava/lang/String;)L";      
-      break;
-    case Opcodes.FALOAD:
-      adviceMethodName = "faload";
-      signature = "([FILjava/lang/String;)F";      
-      break;
-    case Opcodes.DALOAD:
-      adviceMethodName = "daload";
-      signature = "([DILjava/lang/String;)D";      
-      break;
-    case Opcodes.AALOAD:
-      adviceMethodName = "aaload";
-      signature = "([Ljava/lang/Object;ILjava/lang/String;)Ljava/lang/Object;";      
-      break;
-    case Opcodes.BALOAD:
-      adviceMethodName = "baload";
-      signature = "([BILjava/lang/String;)B";      
-      break;
-    case Opcodes.CALOAD:
-      adviceMethodName = "caload";
-      signature = "([CILjava/lang/String;)C";      
-      break;
-    case Opcodes.SALOAD:
-      adviceMethodName = "saload";
-      signature = "([SILjava/lang/String;)S";      
-      break;      
-
-    default:
-      throw new UnsupportedOperationException();
-    }
-    il.add(new LdcInsnNode(location));
-    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, adviceClassName, adviceMethodName, signature));
-    return il;
-  }
-
-  /************************* listeners **********************/
-
-  public static void putfield(Object ref, String className, String fieldName, String source) {
-    if (!source.equals(MOI)) {
-      throw new RuntimeException("UNEXPECTED");
-    }
-    List<FieldAccess> tmp = instanceWrites.get(ref);
-    if (tmp == null) {
-      tmp = new ArrayList<FieldAccess>();
-      instanceWrites.put(ref, tmp);
-    }
-    FieldAccess acc = new FieldAccess(false, false, ref, className, fieldName, source);
-    if (!tmp.contains(acc)) {
-      tmp.add(acc);  
-    }
-  }
-
-  public static void putstatic(String className, String fieldName, String source) {
-    if (!source.equals(MOI)) {
-      throw new RuntimeException("UNEXPECTED");
-    }
-    List<FieldAccess> tmp = staticWrites.get(className);
-    if (tmp == null) {
-      tmp = new ArrayList<FieldAccess>();
-      staticWrites.put(className, tmp);
-    }
-    FieldAccess acc = new FieldAccess(true, false, null, className, fieldName, source);
-    if (!tmp.contains(acc)) {
-      tmp.add(acc);  
-    }
-  }
-
-  public static void getfield(Object ref, String className, String fieldName, String source) {
-    if (source.equals(MOI)) {
-      throw new RuntimeException("UNEXPECTED");
-    }
-    List<FieldAccess> list = instanceWrites.get(ref);
-    if (list != null) {
-      for (FieldAccess acc : list) {
-        if (acc.ref == ref && acc.fieldName.equals(fieldName)) { // BINGO!
-          // BINGO!
-          List<FieldAccess> tmp = instanceReads.get(ref);
-          if (tmp == null) {
-            tmp = new ArrayList<FieldAccess>();
-            instanceReads.put(ref, tmp);
-          }
-          FieldAccess acc2 = new FieldAccess(false, true, ref, className, fieldName, source);
-          if (!tmp.contains(acc2)) {
-            tmp.add(acc2);  
-          }
-        }
-      }
-    }
-  }
-
-  public static void getstatic(String className, String fieldName, String source) {
-    if (source.equals(MOI)) {
-      throw new RuntimeException("UNEXPECTED");
-    }
-    List<FieldAccess> list = staticWrites.get(className);
-    if (list != null) {
-      for (FieldAccess acc : list) {
-        if (acc.className.equals(className) && acc.fieldName.equals(fieldName)) { // BINGO!
-          List<FieldAccess> tmp = staticReads.get(className);
-          if (tmp == null) {
-            tmp = new ArrayList<FieldAccess>();
-            staticReads.put(className, tmp);
-          }
-          FieldAccess acc2 = new FieldAccess(true, false, null, className, fieldName, source);
-          if (!tmp.contains(acc2)) {
-            tmp.add(acc2);  
-          }
-        }
-      }
-    }
-  }
-
-  /* array accesses */
-  public static void iastore(int[] ar, int index, int val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void lastore(long[] ar, int index, long val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void fastore(float[] ar, int index, float val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void dastore(double[] ar, int index, double val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void aastore(Object[] ar, int index, Object val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void bastore(byte[] ar, int index, byte val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void castore(char[] ar, int index, char val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void sastore(short[] ar, int index, short val, String location) {
-    ar[index] = val;
-    writeArrayIndex(ar, index, location);
-  }
-
-  public static void writeArrayIndex(Object aref, int index, String location) {
-    Set<Integer> set = arrayWrites.get(aref);
-    if (set == null) {
-      set = new HashSet<Integer>();
-      arrayWrites.put(aref, set);
-    }
-    if (location.equals(MOI)) {
-      set.add(index);
-    } else {
-      set.remove(index); // killed
-    }
-  }
-
-  public static int iaload(int[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  public static long laload(long[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];    
-  }
-
-  public static float faload(float[] ar, int index, String location) {
-
-    return ar[index];
-  }
-
-  public static double daload(double[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  public static Object aaload(Object[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  public static byte baload(byte[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  public static char caload(char[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  public static short saload(short[] ar, int index, String location) {
-    readArrayIndex(ar, index, location);
-    return ar[index];
-  }
-
-  private static void readArrayIndex(Object aref, int index, String location) {
-    Set<Integer> indices = arrayWrites.get(aref);
-    if (indices != null) {
-      if (indices.contains(index)) {
-        arrayReads.add(new ArrayAccess(aref, index, location));
-      }
-    }
-  }
-
+package instrumentation.options.memaccess;
+
+import instrumentation.options.ITransform;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.FieldInsnNode;
+import org.objectweb.asm.tree.InsnList;
+import org.objectweb.asm.tree.InsnNode;
+import org.objectweb.asm.tree.LdcInsnNode;
+import org.objectweb.asm.tree.MethodInsnNode;
+import org.objectweb.asm.tree.MethodNode;
+
+public class MemoryAccessTransformer implements ITransform { 
+
+  /** method of interest **/
+  public static String MOI = "callret/instrumentation/examples/Sample$WTF.<init>()V";
+
+
+  @SuppressWarnings("unchecked")
+  public void transform(ClassNode cn) {
+
+    for (MethodNode mn : (List<MethodNode>) cn.methods) {
+
+      // method location
+      String location = cn.name + "." + mn.name + mn.desc;
+      boolean inMOI = false;
+      if (MOI.equals(location)) {
+        inMOI = true;
+      }
+
+      InsnList insns = mn.instructions;
+      if (insns.size() == 0) { 
+        continue;
+      }
+      Iterator<AbstractInsnNode> j = insns.iterator();
+      while (j.hasNext()) {
+        AbstractInsnNode in = j.next();
+        int op = in.getOpcode();
+
+
+        if ((op >= Opcodes.IASTORE && op <= Opcodes.SASTORE) ||
+            (op >= Opcodes.IALOAD && op <= Opcodes.SALOAD)) {
+          // array writes in MOI  
+          InsnList list = arrayAccessInstr(op, location);
+          insns.insertBefore(in, list);
+          insns.remove(in);
+        } else if (in instanceof FieldInsnNode) {
+          // field name
+          FieldInsnNode tmp = (FieldInsnNode)in;
+          // class name
+          String owner = tmp.owner;
+          // field name
+          String fieldName = tmp.name;
+
+          boolean isStatic;
+          boolean isStore;
+          //TODO: this will not cover updates on field array
+          if (op == Opcodes.PUTFIELD) {
+            isStatic = false;
+            isStore = true;
+          } else if (op == Opcodes.PUTSTATIC) {
+            isStatic = true;
+            isStore = true;
+          } else if (op >= Opcodes.GETFIELD) {
+            isStatic = false;
+            isStore = false;
+          } else if (op <= Opcodes.GETSTATIC) {
+            isStatic = true;
+            isStore = false;
+          } else {
+            throw new RuntimeException("UNEXPECTED");
+          }
+
+          if (inMOI) {
+            if (isStore) {
+              InsnList list = fieldAccessInstr(isStatic, isStore, owner, fieldName, location);
+              insns.insert(in.getPrevious(), list);
+            }
+          } else if (!isStore) {
+            InsnList list = fieldAccessInstr(isStatic, isStore, owner, fieldName, location);
+            insns.insert(in.getPrevious(), list);
+          }
+        }
+      }
+      // notify on entry
+      mn.maxStack += 10;
+    } 
+  }
+
+  static class FieldAccess {
+    boolean isStatic;
+    boolean isRead;
+    Object ref;
+    String className;
+    String fieldName;
+    String source;
+    public FieldAccess(
+        boolean isStatic, 
+        boolean isRead, 
+        Object ref, 
+        String className,
+        String fieldName, 
+        String source) {
+      this.isStatic = isStatic;
+      this.isRead = isRead;
+      this.ref = ref;
+      this.className = className;
+      this.fieldName = fieldName;
+      this.source = source;
+    }
+    @Override
+    public int hashCode() {
+      return (isStatic?1:0) + (isRead?1:0) + ref.hashCode() + 
+          className.hashCode() + fieldName.hashCode() + 
+          source.hashCode(); 
+    }
+    @Override
+    public boolean equals(Object obj) {
+      boolean result = false;
+      if (obj instanceof FieldAccess) {
+        FieldAccess tmp = (FieldAccess) obj;
+        result = isStatic == tmp.isStatic && 
+            isRead == tmp.isRead && 
+            ref == tmp.ref && 
+            className.equals(tmp.className) && 
+            fieldName.equals(tmp.fieldName) &&
+            source.equals(tmp.source);
+      }
+      return result;
+    }
+  }
+
+  static class ArrayAccess {
+    Object aref;
+    int index;
+    String location;
+    public ArrayAccess(
+        Object aref,
+        int index,
+        String location) {
+      this.aref = aref;
+      this.index = index;
+      this.location = location;
+    }
+    @Override
+    public int hashCode() {
+      return aref.hashCode() + index + location.hashCode(); 
+    }
+    @Override
+    public boolean equals(Object obj) {
+      boolean result = false;
+      if (obj instanceof ArrayAccess) {
+        ArrayAccess tmp = (ArrayAccess) obj;
+        result = 
+            aref == tmp.aref &&
+            index == tmp.index &&
+            location.equals(tmp.location);
+      }
+      return result;
+    }
+  }
+
+  /**
+   * writes on regular fields
+   */
+  static Map<Object, List<FieldAccess>> instanceWrites = new HashMap<Object, List<FieldAccess>>();
+  static Map<String, List<FieldAccess>> staticWrites = new HashMap<String, List<FieldAccess>>(); 
+
+  /**
+   * reads on regular fields
+   */
+  static Map<Object, List<FieldAccess>> instanceReads = new HashMap<Object, List<FieldAccess>>();
+  static Map<String, List<FieldAccess>> staticReads = new HashMap<String, List<FieldAccess>>();    
+
+  /**
+   * writes and reads on array fields
+   */
+  static Map<Object, Set<Integer>> arrayWrites = new HashMap<Object, Set<Integer>>();
+  static Set<ArrayAccess> arrayReads = new HashSet<ArrayAccess>();
+
+
+  public static void dump() {
+    System.out.printf("%d static field interactions!\n", staticReads.size());
+    System.out.printf("%d instance field interactions!\n", instanceReads.size());
+    System.out.printf("%d array interactions!\n", arrayReads.size());
+  }
+
+  /*************** generation of instrumentation code ****************/
+
+  private InsnList fieldAccessInstr(boolean isStatic, boolean isStore, String className, String fieldName, String source) {
+    InsnList il = new InsnList();    
+    String adviceClassName = "callret/instrumentation/MemoryAccessTransformer";
+    String adviceMethodName;
+    if (isStore) {
+      adviceMethodName = "put";
+    } else {
+      adviceMethodName = "get";
+    }
+    if (isStatic) {
+      adviceMethodName += "static";
+    } else {      
+      adviceMethodName += "field";
+    }
+    // filling instruction list with other arguments
+    String signature;
+    if (isStatic) {
+      signature = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V";
+    } else { /*instance*/
+      signature = "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V";
+      if (isStore) {
+        il.add(new InsnNode(Opcodes.DUP2));
+        il.add(new InsnNode(Opcodes.POP));
+      } else {
+        il.add(new InsnNode(Opcodes.DUP));
+      }
+    }
+    il.add(new LdcInsnNode(className));
+    il.add(new LdcInsnNode(fieldName));
+    il.add(new LdcInsnNode(source));    
+    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, adviceClassName, adviceMethodName, signature));
+    return il;
+  }
+
+
+  private InsnList arrayAccessInstr(int op, String location) {
+    InsnList il = new InsnList();    
+    String adviceClassName = "callret/instrumentation/MemoryAccessTransformer";
+    // filling instruction list with other arguments
+    String adviceMethodName;
+    String signature;
+    switch (op) {
+    /* stores */
+    case Opcodes.IASTORE:
+      adviceMethodName = "iastore";
+      signature = "([IIILjava/lang/String;)V";      
+      break;
+    case Opcodes.LASTORE:
+      adviceMethodName = "lastore";
+      signature = "([LILLjava/lang/String;)V";      
+      break;
+    case Opcodes.FASTORE:
+      adviceMethodName = "fastore";
+      signature = "([FIFLjava/lang/String;)V";      
+      break;
+    case Opcodes.DASTORE:
+      adviceMethodName = "dastore";
+      signature = "([DIDLjava/lang/String;)V";      
+      break;
+    case Opcodes.AASTORE:
+      adviceMethodName = "aastore";
+      signature = "([Ljava/lang/Object;ILjava/lang/Object;Ljava/lang/String;)V";      
+      break;
+    case Opcodes.BASTORE:
+      adviceMethodName = "bastore";
+      signature = "([BIBLjava/lang/String;)V";      
+      break;
+    case Opcodes.CASTORE:
+      adviceMethodName = "castore";
+      signature = "([CICLjava/lang/String;)V";      
+      break;
+    case Opcodes.SASTORE:
+      adviceMethodName = "sastore";
+      signature = "([SISLjava/lang/String;)V";      
+      break;
+      /* loads */
+    case Opcodes.IALOAD:
+      adviceMethodName = "iaload";
+      signature = "([IILjava/lang/String;)I";      
+      break;
+    case Opcodes.LALOAD:
+      adviceMethodName = "laload";
+      signature = "([LILjava/lang/String;)L";      
+      break;
+    case Opcodes.FALOAD:
+      adviceMethodName = "faload";
+      signature = "([FILjava/lang/String;)F";      
+      break;
+    case Opcodes.DALOAD:
+      adviceMethodName = "daload";
+      signature = "([DILjava/lang/String;)D";      
+      break;
+    case Opcodes.AALOAD:
+      adviceMethodName = "aaload";
+      signature = "([Ljava/lang/Object;ILjava/lang/String;)Ljava/lang/Object;";      
+      break;
+    case Opcodes.BALOAD:
+      adviceMethodName = "baload";
+      signature = "([BILjava/lang/String;)B";      
+      break;
+    case Opcodes.CALOAD:
+      adviceMethodName = "caload";
+      signature = "([CILjava/lang/String;)C";      
+      break;
+    case Opcodes.SALOAD:
+      adviceMethodName = "saload";
+      signature = "([SILjava/lang/String;)S";      
+      break;      
+
+    default:
+      throw new UnsupportedOperationException();
+    }
+    il.add(new LdcInsnNode(location));
+    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, adviceClassName, adviceMethodName, signature));
+    return il;
+  }
+
+  /************************* listeners **********************/
+
+  public static void putfield(Object ref, String className, String fieldName, String source) {
+    if (!source.equals(MOI)) {
+      throw new RuntimeException("UNEXPECTED");
+    }
+    List<FieldAccess> tmp = instanceWrites.get(ref);
+    if (tmp == null) {
+      tmp = new ArrayList<FieldAccess>();
+      instanceWrites.put(ref, tmp);
+    }
+    FieldAccess acc = new FieldAccess(false, false, ref, className, fieldName, source);
+    if (!tmp.contains(acc)) {
+      tmp.add(acc);  
+    }
+  }
+
+  public static void putstatic(String className, String fieldName, String source) {
+    if (!source.equals(MOI)) {
+      throw new RuntimeException("UNEXPECTED");
+    }
+    List<FieldAccess> tmp = staticWrites.get(className);
+    if (tmp == null) {
+      tmp = new ArrayList<FieldAccess>();
+      staticWrites.put(className, tmp);
+    }
+    FieldAccess acc = new FieldAccess(true, false, null, className, fieldName, source);
+    if (!tmp.contains(acc)) {
+      tmp.add(acc);  
+    }
+  }
+
+  public static void getfield(Object ref, String className, String fieldName, String source) {
+    if (source.equals(MOI)) {
+      throw new RuntimeException("UNEXPECTED");
+    }
+    List<FieldAccess> list = instanceWrites.get(ref);
+    if (list != null) {
+      for (FieldAccess acc : list) {
+        if (acc.ref == ref && acc.fieldName.equals(fieldName)) { // BINGO!
+          // BINGO!
+          List<FieldAccess> tmp = instanceReads.get(ref);
+          if (tmp == null) {
+            tmp = new ArrayList<FieldAccess>();
+            instanceReads.put(ref, tmp);
+          }
+          FieldAccess acc2 = new FieldAccess(false, true, ref, className, fieldName, source);
+          if (!tmp.contains(acc2)) {
+            tmp.add(acc2);  
+          }
+        }
+      }
+    }
+  }
+
+  public static void getstatic(String className, String fieldName, String source) {
+    if (source.equals(MOI)) {
+      throw new RuntimeException("UNEXPECTED");
+    }
+    List<FieldAccess> list = staticWrites.get(className);
+    if (list != null) {
+      for (FieldAccess acc : list) {
+        if (acc.className.equals(className) && acc.fieldName.equals(fieldName)) { // BINGO!
+          List<FieldAccess> tmp = staticReads.get(className);
+          if (tmp == null) {
+            tmp = new ArrayList<FieldAccess>();
+            staticReads.put(className, tmp);
+          }
+          FieldAccess acc2 = new FieldAccess(true, false, null, className, fieldName, source);
+          if (!tmp.contains(acc2)) {
+            tmp.add(acc2);  
+          }
+        }
+      }
+    }
+  }
+
+  /* array accesses */
+  public static void iastore(int[] ar, int index, int val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void lastore(long[] ar, int index, long val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void fastore(float[] ar, int index, float val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void dastore(double[] ar, int index, double val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void aastore(Object[] ar, int index, Object val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void bastore(byte[] ar, int index, byte val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void castore(char[] ar, int index, char val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void sastore(short[] ar, int index, short val, String location) {
+    ar[index] = val;
+    writeArrayIndex(ar, index, location);
+  }
+
+  public static void writeArrayIndex(Object aref, int index, String location) {
+    Set<Integer> set = arrayWrites.get(aref);
+    if (set == null) {
+      set = new HashSet<Integer>();
+      arrayWrites.put(aref, set);
+    }
+    if (location.equals(MOI)) {
+      set.add(index);
+    } else {
+      set.remove(index); // killed
+    }
+  }
+
+  public static int iaload(int[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  public static long laload(long[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];    
+  }
+
+  public static float faload(float[] ar, int index, String location) {
+
+    return ar[index];
+  }
+
+  public static double daload(double[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  public static Object aaload(Object[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  public static byte baload(byte[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  public static char caload(char[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  public static short saload(short[] ar, int index, String location) {
+    readArrayIndex(ar, index, location);
+    return ar[index];
+  }
+
+  private static void readArrayIndex(Object aref, int index, String location) {
+    Set<Integer> indices = arrayWrites.get(aref);
+    if (indices != null) {
+      if (indices.contains(index)) {
+        arrayReads.add(new ArrayAccess(aref, index, location));
+      }
+    }
+  }
+
 }
\ No newline at end of file
diff --git a/src/instrumentation/options/stmt/ExecutionTracer.java b/src/instrumentation/options/stmt/ExecutionTracer.java
index bbc2449..a2eb617 100644
--- a/src/instrumentation/options/stmt/ExecutionTracer.java
+++ b/src/instrumentation/options/stmt/ExecutionTracer.java
@@ -1,149 +1,149 @@
-package instrumentation.options.stmt;
-
-import instrumentation.options.ITransform;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.tree.AbstractInsnNode;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.tree.InsnList;
-import org.objectweb.asm.tree.LabelNode;
-import org.objectweb.asm.tree.LdcInsnNode;
-import org.objectweb.asm.tree.MethodInsnNode;
-import org.objectweb.asm.tree.MethodNode;
-import org.objectweb.asm.tree.TryCatchBlockNode;
-import org.objectweb.asm.util.Printer;
-import org.objectweb.asm.util.Textifier;
-import org.objectweb.asm.util.TraceMethodVisitor;
-
-public class ExecutionTracer implements ITransform { 
-
-  public ExecutionTracer() { } 
-
-  @SuppressWarnings("unchecked")
-  public void transform(ClassNode cn) {
-
-    for (MethodNode mn : (List<MethodNode>) cn.methods) {
-
-      InsnList insns = mn.instructions;
-      if (insns.size() == 0) { 
-        continue;
-      }
-      Iterator<AbstractInsnNode> j = insns.iterator();
-
-      List<LabelNode> exceptionHandlers = new ArrayList<LabelNode>();
-
-      for (int i = 0; i < mn.tryCatchBlocks.size(); i++) {
-        LabelNode lnode = ((TryCatchBlockNode) mn.tryCatchBlocks.get(i)).handler;
-        if (lnode != null) {
-          exceptionHandlers.add(lnode);
-        }
-      }
-
-      while (j.hasNext()) {
-        AbstractInsnNode in = j.next();
-
-        InsnList il = new InsnList();
-        notify(il, insnToString(mn, in));
-        
-        if (in.getPrevious() == null) {
-          // ???
-        } else {
-          insns.insert(in.getPrevious(), il);
-        }
-        
-        
-//        if (op == Opcodes.ATHROW) {
-//          // notify on explicit throws
-//          notify(cn, mn, il, "throwE");
-//          insns.insert(in.getPrevious(), il);
-//        } else if (isRet) {
-//          // notify on exits
-//          notify(cn, mn, il, "exit");
-//          insns.insert(in.getPrevious(), il);
-//        } else if (exceptionHandlers.contains(in)) {
-//          // notify on catches
-//          notify(cn, mn, il, "catchE");
-//          AbstractInsnNode place = getNextRelevant(j);
-//          insns.insert(place.getPrevious(), il);          
-//        }
-
-      }
-
-      // notify on entry
-//      InsnList il = new InsnList(); 
-//      notify(cn, mn, il, "---");      
-//      insns.insert(il); 
-      
-      mn.maxStack += 10;
-      
-//      System.out.println(il.toString());
-      
-    } 
-  }
-
-//  private AbstractInsnNode getNextRelevant(Iterator<AbstractInsnNode> it) {
-//    AbstractInsnNode insn = null;
-//    while (it.hasNext()) {
-//      insn = it.next();
-//      if (insn != null && !(insn instanceof LineNumberNode)) {
-//        break;
-//      }
-//    }
-//    if (insn == null) {
-//      throw new RuntimeException();
-//    }
-//    return insn;
-//  }
-
-  public static String insnToString(MethodNode mn, AbstractInsnNode insn){
-    insn.accept(mp);
-    StringWriter sw = new StringWriter();
-    sw.append(mn.name + " : ");
-    printer.print(new PrintWriter(sw));
-    printer.getText().clear();
-    return sw.toString().replace("\n", "\t");
-  }
-  
-  private static Printer printer = new Textifier();
-  private static TraceMethodVisitor mp = new TraceMethodVisitor(printer); 
-
-  private void notify(InsnList il, String msg) {
-    il.add(new LdcInsnNode(msg));
-    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "instrumentation/options/stmt/ExecutionTracer", "log", "(Ljava/lang/String;)V"));
-  }
-  
-  private static List<String> log = new ArrayList<String>();  
-  
-  public static void log(String msg) {
-    log.add(msg);
-  }
-
-  public static void dump() throws Exception {
-    
-   for (String str : log) {
-     System.out.println(str);
-   }
-   
-   
-//TODO: Need to check why this code raises ClassNotFoundException -Marcelo
-   
-//    StringBuffer buffer = new StringBuffer();
-//    for (String str : log) {
-//      buffer.append(str);
-//      buffer.append("\n");
-//    }
-//    String tmpDir = System.getProperty("java.io.tmpdir");
-//    String fileName = tmpDir + System.getProperty("file.separator") + "trace.out";
-//    FileWriter fw = new FileWriter(fileName);
-//    fw.write(buffer.toString());
-//    fw.flush();
-//    fw.close();
-  }
-
+package instrumentation.options.stmt;
+
+import instrumentation.options.ITransform;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.InsnList;
+import org.objectweb.asm.tree.LabelNode;
+import org.objectweb.asm.tree.LdcInsnNode;
+import org.objectweb.asm.tree.MethodInsnNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.tree.TryCatchBlockNode;
+import org.objectweb.asm.util.Printer;
+import org.objectweb.asm.util.Textifier;
+import org.objectweb.asm.util.TraceMethodVisitor;
+
+public class ExecutionTracer implements ITransform { 
+
+  public ExecutionTracer() { } 
+
+  @SuppressWarnings("unchecked")
+  public void transform(ClassNode cn) {
+
+    for (MethodNode mn : (List<MethodNode>) cn.methods) {
+
+      InsnList insns = mn.instructions;
+      if (insns.size() == 0) { 
+        continue;
+      }
+      Iterator<AbstractInsnNode> j = insns.iterator();
+
+      List<LabelNode> exceptionHandlers = new ArrayList<LabelNode>();
+
+      for (int i = 0; i < mn.tryCatchBlocks.size(); i++) {
+        LabelNode lnode = ((TryCatchBlockNode) mn.tryCatchBlocks.get(i)).handler;
+        if (lnode != null) {
+          exceptionHandlers.add(lnode);
+        }
+      }
+
+      while (j.hasNext()) {
+        AbstractInsnNode in = j.next();
+
+        InsnList il = new InsnList();
+        notify(il, insnToString(mn, in));
+        
+        if (in.getPrevious() == null) {
+          // ???
+        } else {
+          insns.insert(in.getPrevious(), il);
+        }
+        
+        
+//        if (op == Opcodes.ATHROW) {
+//          // notify on explicit throws
+//          notify(cn, mn, il, "throwE");
+//          insns.insert(in.getPrevious(), il);
+//        } else if (isRet) {
+//          // notify on exits
+//          notify(cn, mn, il, "exit");
+//          insns.insert(in.getPrevious(), il);
+//        } else if (exceptionHandlers.contains(in)) {
+//          // notify on catches
+//          notify(cn, mn, il, "catchE");
+//          AbstractInsnNode place = getNextRelevant(j);
+//          insns.insert(place.getPrevious(), il);          
+//        }
+
+      }
+
+      // notify on entry
+//      InsnList il = new InsnList(); 
+//      notify(cn, mn, il, "---");      
+//      insns.insert(il); 
+      
+      mn.maxStack += 10;
+      
+//      System.out.println(il.toString());
+      
+    } 
+  }
+
+//  private AbstractInsnNode getNextRelevant(Iterator<AbstractInsnNode> it) {
+//    AbstractInsnNode insn = null;
+//    while (it.hasNext()) {
+//      insn = it.next();
+//      if (insn != null && !(insn instanceof LineNumberNode)) {
+//        break;
+//      }
+//    }
+//    if (insn == null) {
+//      throw new RuntimeException();
+//    }
+//    return insn;
+//  }
+
+  public static String insnToString(MethodNode mn, AbstractInsnNode insn){
+    insn.accept(mp);
+    StringWriter sw = new StringWriter();
+    sw.append(mn.name + " : ");
+    printer.print(new PrintWriter(sw));
+    printer.getText().clear();
+    return sw.toString().replace("\n", "\t");
+  }
+  
+  private static Printer printer = new Textifier();
+  private static TraceMethodVisitor mp = new TraceMethodVisitor(printer); 
+
+  private void notify(InsnList il, String msg) {
+    il.add(new LdcInsnNode(msg));
+    il.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "instrumentation/options/stmt/ExecutionTracer", "log", "(Ljava/lang/String;)V"));
+  }
+  
+  private static List<String> log = new ArrayList<String>();  
+  
+  public static void log(String msg) {
+    log.add(msg);
+  }
+
+  public static void dump() throws Exception {
+    
+   for (String str : log) {
+     System.out.println(str);
+   }
+   
+   
+//TODO: Need to check why this code raises ClassNotFoundException -Marcelo
+   
+//    StringBuffer buffer = new StringBuffer();
+//    for (String str : log) {
+//      buffer.append(str);
+//      buffer.append("\n");
+//    }
+//    String tmpDir = System.getProperty("java.io.tmpdir");
+//    String fileName = tmpDir + System.getProperty("file.separator") + "trace.out";
+//    FileWriter fw = new FileWriter(fileName);
+//    fw.write(buffer.toString());
+//    fw.flush();
+//    fw.close();
+  }
+
 }
\ No newline at end of file
diff --git a/src/instrumentation/options/stmt/InstructionPrinter.java b/src/instrumentation/options/stmt/InstructionPrinter.java
index 9547a98..cb63e1c 100644
--- a/src/instrumentation/options/stmt/InstructionPrinter.java
+++ b/src/instrumentation/options/stmt/InstructionPrinter.java
@@ -1,90 +1,90 @@
-package instrumentation.options.stmt;
-
-import instrumentation.options.ITransform;
-
-import java.util.Iterator;
-import java.util.List;
-
-import org.objectweb.asm.Attribute;
-import org.objectweb.asm.tree.AbstractInsnNode;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.tree.FieldNode;
-import org.objectweb.asm.tree.InnerClassNode;
-import org.objectweb.asm.tree.MethodNode;
-
-/*******
- * 
- * This is similar to TraceClassVisitor.  See DEBUG.
- * 
- * Please note that this is **NOT** an execution logger
- * 
- *******/
-public class InstructionPrinter implements ITransform { 
-
-  public InstructionPrinter() {
-    // empty
-  }
-
-  @SuppressWarnings("unchecked")
-  public void transform(ClassNode cn) {
-    System.out.println("cn.name: " + cn.name);
-
-    /**
-     * Attributes
-     */
-    List<Attribute> allAttributes = cn.attrs;
-    if (allAttributes != null) {
-
-      for (Attribute attr : allAttributes) {
-        System.out.println("    attr.type: " + attr.type + ", attr.toString: " + attr.toString());
-      }
-
-    }
-
-    /**
-     * Fields
-     */
-    List<FieldNode> allFields = cn.fields;
-    for (FieldNode field : allFields) {
-      System.out.println("    field.name: " + field.name);
-    }
-
-    /**
-     * InnerClasses
-     */
-    List<InnerClassNode> allInnerClassNode = cn.innerClasses;
-    for (InnerClassNode innerClass : allInnerClassNode) {
-      System.out.println("    innerClass.innerName: " + innerClass.innerName +
-          ", innerClass.name: " + innerClass.name +
-          ", innerClass.outerName: " + innerClass.outerName);
-    }
-
-    /**
-     * Interfaces
-     */
-
-    /**
-     * Methods
-     */
-    List<MethodNode> allMethods = cn.methods;
-    for (MethodNode mn : allMethods) {
-
-      // Constructor || Destructor
-      if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name))
-        continue;
-
-      // method without lines (instructions)
-      if (mn.instructions.size() == 0)
-        continue;
-
-      // /////////////////////////////////////
-      System.out.println("    mn.name: " + mn.name);
-
-      Iterator<AbstractInsnNode> j = mn.instructions.iterator();
-      while (j.hasNext()) {
-        AbstractInsnNode abs_ins = j.next();
-        System.out.println("        abs_ins.getOpcode(): " + abs_ins.getOpcode());
-      }
-    }
-  }
-}
+package instrumentation.options.stmt;
+
+import instrumentation.options.ITransform;
+
+import java.util.Iterator;
+import java.util.List;
+
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.FieldNode;
+import org.objectweb.asm.tree.InnerClassNode;
+import org.objectweb.asm.tree.MethodNode;
+
+/*******
+ * 
+ * This is similar to TraceClassVisitor.  See DEBUG.
+ * 
+ * Please note that this is **NOT** an execution logger
+ * 
+ *******/
+public class InstructionPrinter implements ITransform { 
+
+  public InstructionPrinter() {
+    // empty
+  }
+
+  @SuppressWarnings("unchecked")
+  public void transform(ClassNode cn) {
+    System.out.println("cn.name: " + cn.name);
+
+    /**
+     * Attributes
+     */
+    List<Attribute> allAttributes = cn.attrs;
+    if (allAttributes != null) {
+
+      for (Attribute attr : allAttributes) {
+        System.out.println("    attr.type: " + attr.type + ", attr.toString: " + attr.toString());
+      }
+
+    }
+
+    /**
+     * Fields
+     */
+    List<FieldNode> allFields = cn.fields;
+    for (FieldNode field : allFields) {
+      System.out.println("    field.name: " + field.name);
+    }
+
+    /**
+     * InnerClasses
+     */
+    List<InnerClassNode> allInnerClassNode = cn.innerClasses;
+    for (InnerClassNode innerClass : allInnerClassNode) {
+      System.out.println("    innerClass.innerName: " + innerClass.innerName +
+          ", innerClass.name: " + innerClass.name +
+          ", innerClass.outerName: " + innerClass.outerName);
+    }
+
+    /**
+     * Interfaces
+     */
+
+    /**
+     * Methods
+     */
+    List<MethodNode> allMethods = cn.methods;
+    for (MethodNode mn : allMethods) {
+
+      // Constructor || Destructor
+      if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name))
+        continue;
+
+      // method without lines (instructions)
+      if (mn.instructions.size() == 0)
+        continue;
+
+      // /////////////////////////////////////
+      System.out.println("    mn.name: " + mn.name);
+
+      Iterator<AbstractInsnNode> j = mn.instructions.iterator();
+      while (j.hasNext()) {
+        AbstractInsnNode abs_ins = j.next();
+        System.out.println("        abs_ins.getOpcode(): " + abs_ins.getOpcode());
+      }
+    }
+  }
+}
diff --git a/src/replayer/CallStack.java b/src/replayer/CallStack.java
index 3b6ee7c..97bb827 100644
--- a/src/replayer/CallStack.java
+++ b/src/replayer/CallStack.java
@@ -1,27 +1,27 @@
-package replayer;
-
-import java.util.EmptyStackException;
-import java.util.Stack;
-
-public class CallStack {
-
-  private Stack<OperandStack> stack = new Stack<OperandStack>();
-
-  public OperandStack push(String mName) {
-    OperandStack result = new OperandStack(mName);
-    stack.push(result);
-    return result;
-  }
-
-  public OperandStack pop() {
-    stack.pop();
-    OperandStack tmp = null;
-    try {
-      tmp = stack.peek();
-    } catch (EmptyStackException _)  { 
-      throw new FinishedExecutionException();
-    }
-    return tmp;
-  }
-
+package replayer;
+
+import java.util.EmptyStackException;
+import java.util.Stack;
+
+public class CallStack {
+
+  private Stack<OperandStack> stack = new Stack<OperandStack>();
+
+  public OperandStack push(String mName) {
+    OperandStack result = new OperandStack(mName);
+    stack.push(result);
+    return result;
+  }
+
+  public OperandStack pop() {
+    stack.pop();
+    OperandStack tmp = null;
+    try {
+      tmp = stack.peek();
+    } catch (EmptyStackException _)  { 
+      throw new FinishedExecutionException();
+    }
+    return tmp;
+  }
+
 }
\ No newline at end of file
diff --git a/src/replayer/FinishedExecutionException.java b/src/replayer/FinishedExecutionException.java
index fb68f31..87b4d95 100644
--- a/src/replayer/FinishedExecutionException.java
+++ b/src/replayer/FinishedExecutionException.java
@@ -1,6 +1,6 @@
-package replayer;
-
-@SuppressWarnings("serial")
-public class FinishedExecutionException extends RuntimeException {
-
-}
+package replayer;
+
+@SuppressWarnings("serial")
+public class FinishedExecutionException extends RuntimeException {
+
+}
diff --git a/src/replayer/Heap.java b/src/replayer/Heap.java
index b4221a7..73a03a5 100644
--- a/src/replayer/Heap.java
+++ b/src/replayer/Heap.java
@@ -1,19 +1,19 @@
-package replayer;
-
-import java.util.HashSet;
-import java.util.Set;
-
-public class Heap {
-
-  /**
-   * Fields
-   */
-  private Set<HeapCell> object = new HashSet<HeapCell>();
-
-  public HeapCell newCell() {
-    HeapCell res = new HeapCell();
-    object.add(res);
-    return res;
-  }
-
-}
+package replayer;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class Heap {
+
+  /**
+   * Fields
+   */
+  private Set<HeapCell> object = new HashSet<HeapCell>();
+
+  public HeapCell newCell() {
+    HeapCell res = new HeapCell();
+    object.add(res);
+    return res;
+  }
+
+}
diff --git a/src/replayer/HeapCell.java b/src/replayer/HeapCell.java
index 11f00c1..cb5cf03 100644
--- a/src/replayer/HeapCell.java
+++ b/src/replayer/HeapCell.java
@@ -1,19 +1,19 @@
-package replayer;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class HeapCell {
-
-  // non-native
-  private Map<String, Object> map = new HashMap<String, Object>();
-
-  public Object load(String name) {
-    return map.get(name);
-  }
-
-  public void store(String name, Object val) {
-    assert val instanceof HeapCell || val.getClass().isPrimitive();
-    map.put(name, val);
-  }
+package replayer;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class HeapCell {
+
+  // non-native
+  private Map<String, Object> map = new HashMap<String, Object>();
+
+  public Object load(String name) {
+    return map.get(name);
+  }
+
+  public void store(String name, Object val) {
+    assert val instanceof HeapCell || val.getClass().isPrimitive();
+    map.put(name, val);
+  }
 }
\ No newline at end of file
diff --git a/src/replayer/Main.java b/src/replayer/Main.java
index 006fb41..0d8cf52 100644
--- a/src/replayer/Main.java
+++ b/src/replayer/Main.java
@@ -58,9 +58,7 @@ public class Main {
     LINENUMBER, IADD, IRETURN, POP, ISUB, IMUL, IDIV, IREM, 
     INEG, IAND, IOR, ISHL, ISHR, IUSHR, IXOR, LCMP, IF, GOTO, 
     FRAME, ANEWARRAY, AASTORE, PUTSTATIC, GETFIELD, AALOAD, SIPUSH,
-    DSTORE, DLOAD, DMUL, DADD, DDIV, DSUB, LOOKUPSWITCH, INVOKEVIRTUAL,
-    LRETURN, LSHL, LSHR, FDIV, FSTORE, LSTORE, FLOAD, LLOAD, 
-    FASTORE, FCMPG, FCMPL, FCONST
+    DSTORE, DLOAD, DMUL, DADD, DDIV, DSUB, LOOKUPSWITCH, INVOKEVIRTUAL
   };
 
   /**
@@ -166,42 +164,6 @@ public class Main {
        * decide which instruction to apply
        */
       switch (kind) {
-              //----------------------------------------------mra2--->
-        case FASTORE:
-              Object val_f = operandStack.pop();
-              int index_f = (Integer) operandStack.pop();
-              HeapCell arRef_f = (HeapCell) operandStack.pop();
-              arRef_f.store(index_f+"", val_f);
-              break;
-        case FCMPG:
-              float val_g = (float) operandStack.pop();
-              float val2_g = (float) operandStack.pop();
-              
-              if(val_g > val2_g){
-                  operandStack.push(1);
-              }else if(val_g == val2_g){
-                  operandStack.push(0);
-              }else{
-                  operandStack.push(-1);
-              }
-              break;
-        case FCMPL:
-              float val_l = (Float) ((Double) operandStack.pop()).floatValue();
-              float val2_l = (Float) ((Double) operandStack.pop()).floatValue();
-              
-              if(val_l > val2_l){
-                  operandStack.push(1);
-              }else if(val_l == val2_l){
-                  operandStack.push(0);
-              }else{
-                  operandStack.push(-1);
-              }
-              break;
-        case FCONST:
-              float tmp3 = Float.parseFloat(complementOne);
-              operandStack.push(tmp3);
-              break;
-              //----------------------------------------------mra2--->
 
       case BIPUSH:
         operandStack.push(Integer.parseInt(complementOne));
@@ -530,55 +492,6 @@ public class Main {
         i = lookupForLabel(labels, gotoLabel, i);
         break;
 
-      case LRETURN:
-        long val3 = ((Integer) operandStack.pop()).longValue();
-        operandStack = callStack.pop();
-        operandStack.push(val3);
-        break;        
-        
-      case LSHL:
-      case LSHR:
-        
-        long val4 = ((Integer) operandStack.pop()).longValue();
-        int val5 = ((Integer) operandStack.pop()).intValue();
-	long resp2;
-        
-        switch(kind) {
-          case LSHL:
-            resp2 = val4 << val5;
-            break;
-          case LSHR:
-            resp2 = val4 >> val5;
-            break;          
-          default:
-            throw new RuntimeException("Interpretation of Instruction undefined: " + kind);
-        }
-
-        operandStack.push(resp2);
-        break;
-
-      case FDIV:
-        float f1 = (Float) ((Double) operandStack.pop()).floatValue();
-        float f2 = (Float) ((Double) operandStack.pop()).floatValue();  
-        float resp = f1 / f2;
-        operandStack.push(new Double (resp));     //testar pra ver se funciona, retornar um float em uma classe double
-        break;
-
-      case FSTORE:
-        operandStack.store(Integer.parseInt(complementOne));
-        break;
-
-      case LSTORE:
-        operandStack.store(Integer.parseInt(complementOne));
-        break;
-
-      case FLOAD:
-        operandStack.load(Integer.parseInt(complementOne));
-        break;
-      case LLOAD:
-        operandStack.load(Integer.parseInt(complementOne));
-        break;
-
       default:
         throw new RuntimeException("Interpretation of Instruction undefined: " + kind);
       }
@@ -647,4 +560,4 @@ public class Main {
   }
 
 
-}
+}
\ No newline at end of file
diff --git a/src/replayer/OperandStack.java b/src/replayer/OperandStack.java
index 02290ac..2d5f346 100644
--- a/src/replayer/OperandStack.java
+++ b/src/replayer/OperandStack.java
@@ -1,44 +1,44 @@
-package replayer;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Stack;
-
-
-class OperandStack {
-
-  @SuppressWarnings("unused")
-  private String mName;
-  private Map<Integer, Object> locals = new HashMap<Integer, Object>();
-  private Stack<Object> stack = new Stack<Object>();
-
-  OperandStack(String mName) {
-    this.mName = mName;
-  }
-
-  void push(Object val) {
-    stack.push(val);
-  }
-
-  public void store(int local) {
-    locals.put(local, stack.pop());
-  }
-
-  public void store(int j, Object object) {
-    locals.put(j, object);
-  }
-
-  public void load(int local) {
-    stack.push(locals.get(local));
-  }
-
-  public Object pop() {
-    return stack.pop();
-  }
-
-  public Object peek() {
-    return stack.peek();
-  }
-
-
+package replayer;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
+
+
+class OperandStack {
+
+  @SuppressWarnings("unused")
+  private String mName;
+  private Map<Integer, Object> locals = new HashMap<Integer, Object>();
+  private Stack<Object> stack = new Stack<Object>();
+
+  OperandStack(String mName) {
+    this.mName = mName;
+  }
+
+  void push(Object val) {
+    stack.push(val);
+  }
+
+  public void store(int local) {
+    locals.put(local, stack.pop());
+  }
+
+  public void store(int j, Object object) {
+    locals.put(j, object);
+  }
+
+  public void load(int local) {
+    stack.push(locals.get(local));
+  }
+
+  public Object pop() {
+    return stack.pop();
+  }
+
+  public Object peek() {
+    return stack.peek();
+  }
+
+
 }
\ No newline at end of file
diff --git a/src/replayer/StaticArea.java b/src/replayer/StaticArea.java
index cc5b770..46f92fe 100644
--- a/src/replayer/StaticArea.java
+++ b/src/replayer/StaticArea.java
@@ -1,28 +1,28 @@
-package replayer;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class StaticArea {
-  
-  private Map<Class<?>, Map<String, Object>> sa = new HashMap<Class<?>, Map<String, Object>>();
-
-  public void putStatic(Class<?> clazz, String fieldName, Object val) {
-    Map<String, Object> table = sa.get(clazz);
-    if (table == null) {
-      table = new HashMap<String, Object>();
-      sa.put(clazz, table);
-    }
-    table.put(fieldName, val);
-  }
-  
-  public Object getStatic(Class<?> clazz, String fieldName) {
-    Map<String, Object> table = sa.get(clazz);
-    if (table == null) {
-      table = new HashMap<String, Object>();
-      sa.put(clazz, table);
-    }
-    return table.get(fieldName);
-  }
-  
+package replayer;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class StaticArea {
+  
+  private Map<Class<?>, Map<String, Object>> sa = new HashMap<Class<?>, Map<String, Object>>();
+
+  public void putStatic(Class<?> clazz, String fieldName, Object val) {
+    Map<String, Object> table = sa.get(clazz);
+    if (table == null) {
+      table = new HashMap<String, Object>();
+      sa.put(clazz, table);
+    }
+    table.put(fieldName, val);
+  }
+  
+  public Object getStatic(Class<?> clazz, String fieldName) {
+    Map<String, Object> table = sa.get(clazz);
+    if (table == null) {
+      table = new HashMap<String, Object>();
+      sa.put(clazz, table);
+    }
+    return table.get(fieldName);
+  }
+  
 }
\ No newline at end of file
diff --git a/src/replayer/Util.java b/src/replayer/Util.java
index db1f21d..33d291d 100644
--- a/src/replayer/Util.java
+++ b/src/replayer/Util.java
@@ -1,85 +1,85 @@
-package replayer;
-
-import java.lang.reflect.AccessibleObject;
-import java.util.ArrayList;
-import java.util.List;
-
-public class Util {
-
-  public static AccessibleObject lookup(String[] args) {
-    try {
-      Class<?> clazz = Class.forName(args[0].replace('/', '.'));
-      String params = "";
-//      if (!args[2].startsWith("()")) {
-//        System.out.println(Arrays.toString(args) + "===> " + args[2]);
-       params = args[2].substring(args[2].indexOf("(")+1, args[2].indexOf(")"));
-//      }
-      List<Class<?>> list = new ArrayList<Class<?>>();
-      while (!params.equals("")) {
-        char c = params.charAt(0);
-        Class<?> tp;
-        switch (c) {
-        case 'I':
-          tp = Integer.TYPE;
-          break;
-        case 'S':
-          tp = Short.TYPE;
-          break;
-        case 'B':
-          tp = Byte.TYPE;
-          break;
-        case 'C':
-          tp = Character.TYPE;
-          break;
-        case 'F':
-          tp = Float.TYPE;
-          break;
-        case 'D':
-          tp = Double.TYPE;
-          break;
-        case 'Z':
-          tp = Boolean.TYPE;
-          break;
-        case 'J':
-          tp = Long.TYPE;
-          break;
-        case 'V':
-          tp = Void.TYPE;
-          break;
-        case 'L':
-          int idx = params.indexOf(";");
-          String tmp = params.substring(1, idx);
-          tp = Class.forName(tmp.replace("/", "."));
-          params = params.substring(idx+1);
-          break;
-        default:
-          throw new RuntimeException("missing implementation --->" + c);
-        }
-        if (params.length() > 0) {
-          if (c != 'L') {
-            params = params.substring(1);
-          }
-        } else {
-          params = "";
-        }
-        list.add(tp);
-      }
-      Class<?>[] ar = new Class<?>[list.size()];
-      list.toArray(ar);
-
-      AccessibleObject aobj;
-      if (args[1].equals("<init>")) {
-        aobj = clazz.getDeclaredConstructor(ar);
-      } else {
-        aobj = clazz.getDeclaredMethod(args[1], ar);
-      }
-      aobj.setAccessible(true);
-      return aobj;
-    } catch (Exception e) {
-      e.printStackTrace();
-      throw new RuntimeException("unexpected");
-    }
-
-  }
-
-}
+package replayer;
+
+import java.lang.reflect.AccessibleObject;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Util {
+
+  public static AccessibleObject lookup(String[] args) {
+    try {
+      Class<?> clazz = Class.forName(args[0].replace('/', '.'));
+      String params = "";
+//      if (!args[2].startsWith("()")) {
+//        System.out.println(Arrays.toString(args) + "===> " + args[2]);
+       params = args[2].substring(args[2].indexOf("(")+1, args[2].indexOf(")"));
+//      }
+      List<Class<?>> list = new ArrayList<Class<?>>();
+      while (!params.equals("")) {
+        char c = params.charAt(0);
+        Class<?> tp;
+        switch (c) {
+        case 'I':
+          tp = Integer.TYPE;
+          break;
+        case 'S':
+          tp = Short.TYPE;
+          break;
+        case 'B':
+          tp = Byte.TYPE;
+          break;
+        case 'C':
+          tp = Character.TYPE;
+          break;
+        case 'F':
+          tp = Float.TYPE;
+          break;
+        case 'D':
+          tp = Double.TYPE;
+          break;
+        case 'Z':
+          tp = Boolean.TYPE;
+          break;
+        case 'J':
+          tp = Long.TYPE;
+          break;
+        case 'V':
+          tp = Void.TYPE;
+          break;
+        case 'L':
+          int idx = params.indexOf(";");
+          String tmp = params.substring(1, idx);
+          tp = Class.forName(tmp.replace("/", "."));
+          params = params.substring(idx+1);
+          break;
+        default:
+          throw new RuntimeException("missing implementation --->" + c);
+        }
+        if (params.length() > 0) {
+          if (c != 'L') {
+            params = params.substring(1);
+          }
+        } else {
+          params = "";
+        }
+        list.add(tp);
+      }
+      Class<?>[] ar = new Class<?>[list.size()];
+      list.toArray(ar);
+
+      AccessibleObject aobj;
+      if (args[1].equals("<init>")) {
+        aobj = clazz.getDeclaredConstructor(ar);
+      } else {
+        aobj = clazz.getDeclaredMethod(args[1], ar);
+      }
+      aobj.setAccessible(true);
+      return aobj;
+    } catch (Exception e) {
+      e.printStackTrace();
+      throw new RuntimeException("unexpected");
+    }
+
+  }
+
+}
diff --git a/src/replayer/examples/Samples.java b/src/replayer/examples/Samples.java
index 2db7617..8356558 100644
--- a/src/replayer/examples/Samples.java
+++ b/src/replayer/examples/Samples.java
@@ -1,56 +1,56 @@
-package replayer.examples;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class Samples {
-
-
-  static List<String> sample1() {
-    List<String> result = new ArrayList<String>();
-    result.add("bipush 10");
-    result.add("istore_1");
-    result.add("iload_1");
-    result.add("iconst_2");
-    result.add("imul");
-    result.add("istore_1");
-    result.add("return");
-    return result;
-  }
-
-  static List<String> sample2() {
-    List<String> result = new ArrayList<String>();
-    result.add("iconst_1");
-    result.add("newarray int");
-    result.add("dup");
-    result.add("iconst_0");
-    result.add("bipush	10");
-    result.add("iastore");
-    result.add("astore_1");
-    result.add("aload_1");
-    result.add("iconst_0");
-    result.add("aload_1");
-    result.add("iconst_0");
-    result.add("iaload");
-    result.add("iconst_2");
-    result.add("imul");
-    result.add("iastore");
-    result.add("return");
-    return result;
-  }
-
-  public static List<String> sample3() {
-    List<String> result = new ArrayList<String>();
-    result.add("iconst_5");
-    result.add("bipush	10");
-    result.add("invokestatic	#2; //Method foo:(II)I");
-    result.add("iload_0");
-    result.add("iload_1");
-    result.add("iadd");
-    result.add("ireturn");
-    result.add("istore_1");
-    result.add("return");
-    return result;
-  }
-
+package replayer.examples;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Samples {
+
+
+  static List<String> sample1() {
+    List<String> result = new ArrayList<String>();
+    result.add("bipush 10");
+    result.add("istore_1");
+    result.add("iload_1");
+    result.add("iconst_2");
+    result.add("imul");
+    result.add("istore_1");
+    result.add("return");
+    return result;
+  }
+
+  static List<String> sample2() {
+    List<String> result = new ArrayList<String>();
+    result.add("iconst_1");
+    result.add("newarray int");
+    result.add("dup");
+    result.add("iconst_0");
+    result.add("bipush	10");
+    result.add("iastore");
+    result.add("astore_1");
+    result.add("aload_1");
+    result.add("iconst_0");
+    result.add("aload_1");
+    result.add("iconst_0");
+    result.add("iaload");
+    result.add("iconst_2");
+    result.add("imul");
+    result.add("iastore");
+    result.add("return");
+    return result;
+  }
+
+  public static List<String> sample3() {
+    List<String> result = new ArrayList<String>();
+    result.add("iconst_5");
+    result.add("bipush	10");
+    result.add("invokestatic	#2; //Method foo:(II)I");
+    result.add("iload_0");
+    result.add("iload_1");
+    result.add("iadd");
+    result.add("ireturn");
+    result.add("istore_1");
+    result.add("return");
+    return result;
+  }
+
 }
\ No newline at end of file
